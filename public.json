{
  "swagger": "2.0",
  "info": {
    "version": "1.0.0",
    "title": "Azure Standard Public API",
    "description": "The public API behind Azure's website",
    "contact": {
      "name": "Azure Standard Customer Service",
      "email": "info@azurestandard.com",
      "url": "https://azurestandard.com/customer-service"
    },
    "license": {
      "name": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  },
  "security": [
    {
      "basic": []
    },
    {
      "sessionCookie": []
    }
  ],
  "securityDefinitions": {
    "basic": {
      "type": "basic",
      "description": "Basic authentication (http://tools.ietf.org/html/rfc2617#section-2)"
    },
    "sessionCookie": {
      "type": "apiKey",
      "in": "header",
      "name": "cookie",
      "description": "Session cookie (http://tools.ietf.org/html/rfc6265)"
    }
  },
  "host": "api.azurestandard.com",
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/bartender-hosts": {
      "get": {
        "summary": "Returns all BarTender hosts from the system that the user has access to",
        "operationId": "findBartenderHosts",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "bartenderHost response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/bartenderHost"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new BarTender host",
        "operationId": "addBartenderHost",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "host",
            "in": "body",
            "description": "BarTender host to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/bartenderHost"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender host response",
            "schema": {
              "$ref": "#/definitions/bartenderHost"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/bartender-host/{code}": {
      "get": {
        "summary": "Returns a BarTender host based on a single code, if the user has access to it",
        "operationId": "findBartenderHostByCode",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "code of BarTender host to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender host response",
            "schema": {
              "$ref": "#/definitions/bartenderHost"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing BarTender host",
        "operationId": "updateBartenderHost",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "code of BarTender host to update",
            "required": true,
            "type": "string"
          },
          {
            "name": "host",
            "in": "body",
            "description": "Updated BarTender host parameters (can optionally include 'code')",
            "required": true,
            "schema": {
              "$ref": "#/definitions/bartenderHost"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender host response",
            "schema": {
              "$ref": "#/definitions/bartenderHost"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing BarTender host",
        "operationId": "deleteBartenderHost",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "code of BarTender host to delete",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/bartender-templates": {
      "get": {
        "summary": "Returns all BarTender templates from the system that the user has access to",
        "operationId": "findBartenderTemplates",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "bartenderTemplate response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/bartenderTemplate"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new BarTender template",
        "operationId": "addBartenderTemplate",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "template",
            "in": "body",
            "description": "BarTender template to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/bartenderTemplate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender template response",
            "schema": {
              "$ref": "#/definitions/bartenderTemplate"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/bartender-template/{id}": {
      "get": {
        "summary": "Returns a BarTender template based on a single ID, if the user has access to it",
        "operationId": "findBartenderTemplateById",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender template to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender template response",
            "schema": {
              "$ref": "#/definitions/bartenderTemplate"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing BarTender template",
        "operationId": "updateBartenderTemplate",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender template to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "template",
            "in": "body",
            "description": "Updated BarTender template parameters (can optionally include 'id')",
            "required": true,
            "schema": {
              "$ref": "#/definitions/bartenderTemplate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender template response",
            "schema": {
              "$ref": "#/definitions/bartenderTemplate"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing BarTender template",
        "operationId": "deleteBartenderTemplate",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender template to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/bartender-print-configurations": {
      "get": {
        "summary": "Returns all BarTender print configurations from the system that the user has access to",
        "operationId": "findBartenderPrintConfigurations",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "bartenderPrintConfiguration response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/bartenderPrintConfiguration"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new BarTender print configuration",
        "operationId": "addBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "print-configuration",
            "in": "body",
            "description": "BarTender print configuration to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/bartenderPrintConfiguration"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender print configuration response",
            "schema": {
              "$ref": "#/definitions/bartenderPrintConfiguration"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/bartender-print-configuration/{id}": {
      "get": {
        "summary": "Returns a BarTender print configuration based on a single ID, if the user has access to it",
        "operationId": "findBartenderPrintConfigurationById",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender print configuration response",
            "schema": {
              "$ref": "#/definitions/bartenderPrintConfiguration"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing BarTender print configuration",
        "operationId": "updateBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "print-configuration",
            "in": "body",
            "description": "Updated BarTender print configuration parameters (can optionally include 'id')",
            "required": true,
            "schema": {
              "$ref": "#/definitions/bartenderPrintConfiguration"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender print configuration response",
            "schema": {
              "$ref": "#/definitions/bartenderPrintConfiguration"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing BarTender print configuration",
        "operationId": "deleteBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/bartender-print-configuration/{id}/actions/test-print": {
      "post": {
        "summary": "Create a test BarTender print request using this print configuration.  The print request uses hard-coded dummy data.",
        "operationId": "actionTestBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to test",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "202": {
            "description": "BarTender print configuration test print request accepted"
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/drops": {
      "get": {
        "summary": "Returns all drops from the system that the user has access to",
        "operationId": "findDrops",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active drops",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Order results by this field.  Only one special sort field is supported, \"distance(lat:45.45|lon:-121.13)\", which will sort drops by increasing distance from the lat and lon combination."
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/drop"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new drop",
        "operationId": "addDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "body",
            "description": "Drop to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newDrop"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "$ref": "#/definitions/drop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drop/{id}": {
      "get": {
        "summary": "Returns a drop based on a single ID, if the user has access to the drop",
        "operationId": "findDropById",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "$ref": "#/definitions/drop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing drop",
        "operationId": "updateDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "drop",
            "in": "body",
            "description": "Updated drop parameters (can optionally include 'id')",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateDrop"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "$ref": "#/definitions/drop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing drop",
        "operationId": "deleteDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drops/locations": {
      "get": {
        "summary": "Returns an array of locations for all active drops that the user has access to.",
        "description": "For example, you can use this to draw markers on map.",
        "operationId": "findDropLocations",
        "tags": [
          "drop"
        ],
        "responses": {
          "200": {
            "description": "drop locations response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/location"
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drop-memberships": {
      "get": {
        "summary": "Returns all drop memberships from the system that the user has access to",
        "operationId": "findDropMemberships",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active memberships",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "pending",
            "in": "query",
            "description": "only return pending (true) or accepted (false) memberships",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include a full representation of the inlined property.  Currently supports \"customer\", \"customer.email\", and \"drop\".",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/dropMembership"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new drop membership",
        "operationId": "addDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "drop-membership",
            "in": "body",
            "description": "drop membership to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newDropMembership"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "$ref": "#/definitions/dropMembership"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drop-membership/{id}": {
      "get": {
        "summary": "Returns a drop membership based on a single membership ID, if the user has access.",
        "operationId": "findDropMembershipById",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include a full representation of the inlined property.  Currently supports \"customer\" and \"drop\".",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "$ref": "#/definitions/dropMembership"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing drop membership if the user has the access.",
        "operationId": "updateDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "drop-membership",
            "in": "body",
            "description": "Updated drop membership parameters",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateDropMembership"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "$ref": "#/definitions/dropMembership"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing drop membership",
        "operationId": "deleteDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/pickups": {
      "get": {
        "summary": "Returns all pickups from the system that the user has access to",
        "operationId": "findPickups",
        "tags": [
          "pickup"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active pickups",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "vendor",
            "in": "query",
            "description": "vendor IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "pickup response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/pickup"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you didn't set `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/pickup/{id}": {
      "get": {
        "summary": "Returns a pickup based on a single ID, if the user has access to the pickup",
        "operationId": "findPickupById",
        "tags": [
          "pickup"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of pickup to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "pickup response",
            "schema": {
              "$ref": "#/definitions/pickup"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/routes": {
      "get": {
        "summary": "Returns all routes from the system that the user has access to",
        "operationId": "findRoutes",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/route"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new route",
        "operationId": "addRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "body",
            "description": "Route to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newRoute"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "$ref": "#/definitions/route"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/route/{name}": {
      "get": {
        "summary": "Returns a route based on a single ID, if the user has access to the route",
        "operationId": "findRouteById",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of route to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "$ref": "#/definitions/route"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing route",
        "operationId": "updateRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of route to update",
            "required": true,
            "type": "string"
          },
          {
            "name": "route",
            "in": "body",
            "description": "update route parameters",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateRoute"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "$ref": "#/definitions/route"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing route",
        "operationId": "deleteRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of route to delete",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/trips": {
      "get": {
        "summary": "Returns all trips from the system that the user has access to",
        "description": "Trips are ordered for decreasing cutoff time",
        "operationId": "findTrips",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "stop",
            "in": "query",
            "description": "stop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "cutoff-after",
            "in": "query",
            "description": "only return trips with cutoffs after or on this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "cutoff-before",
            "in": "query",
            "description": "only return trips with cutoffs before this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "confirmed",
            "in": "query",
            "description": "only return (un)confirmed trips",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/trip"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Creates a trip for a route, if the user has permissions",
        "operationId": "addTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "trip",
            "in": "body",
            "description": "Trip to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateTrip"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "$ref": "#/definitions/trip"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/trip/{id}": {
      "get": {
        "summary": "Returns a trip based on a single ID, if the user has access to the trip",
        "operationId": "findTripById",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "$ref": "#/definitions/trip"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Updates a trip for a route, if the user has permissions",
        "operationId": "updateTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "trip",
            "in": "body",
            "description": "Trip to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateTrip"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "$ref": "#/definitions/trip"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Deletes a trip for a route, if the user has permissions",
        "operationId": "deleteTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/route-stops": {
      "get": {
        "summary": "Returns all route-stops from the system that the user has access to",
        "description": "Route-stops are ordered for increasing offset from the route's trip cutoff",
        "operationId": "findRouteStops",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "route-stop response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/routeStop"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/route-stop/{id}": {
      "get": {
        "summary": "Returns a route-stop based on a single ID, if the user has access to the route-stop",
        "operationId": "findRouteStopById",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of route-stop to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "route-stop response",
            "schema": {
              "$ref": "#/definitions/routeStop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/stops": {
      "get": {
        "summary": "Returns all stops from the system that the user has access to",
        "description": "Stops are ordered for decreasing target time",
        "operationId": "findStops",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "pickup",
            "in": "query",
            "description": "pickup IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "target-time-after",
            "in": "query",
            "description": "only return stops with a target time after or on this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "target-time-before",
            "in": "query",
            "description": "only return stops with a target time before this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "short-drop",
            "in": "query",
            "description": "only return stops which have (not) had short-drop warnings sent.",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "stop response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/stop"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new stop on a trip",
        "operationId": "addStop",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "stop",
            "in": "body",
            "description": "stop to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateStop"
            }
          },
          {
            "name": "persist",
            "in": "query",
            "description": "if true, calculate the offset between the trips's delivery start and this stop's estimated time.  For any pre-cutoff trips associated with this stop's trip's route which cutoff later than this stop's trip, create a stop for this location (drop or pickup) if it does not already exist and update that stop's target and estimated times to have the same offset from that stops's trip's delivery start.  Also create a route-stop association, if it does not already exist, for this location on this stop's trip's route and update that route-stop with the same delivery offset.",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "stop response",
            "schema": {
              "$ref": "#/definitions/stop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/stop/{id}": {
      "get": {
        "summary": "Returns a stop based on a single ID, if the user has access to the stop",
        "operationId": "findStopById",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of stop to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "stop response",
            "schema": {
              "$ref": "#/definitions/stop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing stop",
        "operationId": "updateStop",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of stop to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "stop",
            "in": "body",
            "description": "stop to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateStop"
            }
          },
          {
            "name": "persist",
            "in": "query",
            "description": "if true, calculate the offset between the trips's delivery start and this stop's estimated time.  For any pre-cutoff trips associated with this stop's trip's route which cutoff later than this stop's trip, create a stop for this location (drop or pickup) if it does not already exist and update that stop's target and estimated times to have the same offset from that stops's trip's delivery start.  Also create a route-stop association, if it does not already exist, for this location on this stop's trip's route and update that route-stop with the same delivery offset.  If propagate is set, apply the persistance logic to the later stops on the trip as well.",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "propagate",
            "in": "query",
            "description": "if true, calculate the change from the existing estimated time.  Shift the estimated time of all later stops on the trip by the same amount.  For pre-cutoff trips, also shift the target times.",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "stop response",
            "schema": {
              "$ref": "#/definitions/stop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing stop",
        "operationId": "deleteStop",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of stop to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "persist",
            "in": "query",
            "description": "if true, for any pre-cutoff trips associated with this stop's trip's route which cutoff later than this stop's trip, delete any stops for this location (drop or pickup).  Also delete any route-stop associations for this location on this stop's trip's route.",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/audit/products": {
      "get": {
        "summary": "Returns all products and their packaging from the system",
        "operationId": "findProductAudits",
        "tags": [
          "audit",
          "product"
        ],
        "parameters": [
          {
            "name": "audited",
            "in": "query",
            "description": "filter for products that have or haven't been audited.  When set, only products that contain (un)audited packaging are returned, and their packaging array only contains (un)audited packaging.",
            "required": false,
            "type": "string"
          },
          {
            "name": "search",
            "in": "query",
            "description": "search string for filtering products.  The logic behind this is left up to the implementation, but it should at least match words in the product name, and may optionally match the product description or other characteristics",
            "required": false,
            "type": "string"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged-product codes to filter by.",
            "required": false,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "product audit response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/productAudit"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/audit/product/{id}": {
      "get": {
        "summary": "Returns a product based on a single ID",
        "operationId": "findProductAuditById",
        "tags": [
          "audit",
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of product to fetch",
            "required": true,
            "type": "string"
          },
          {
            "name": "audited",
            "in": "query",
            "description": "When set, the packaging array only contains (un)audited packaging.",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "product audit response",
            "schema": {
              "$ref": "#/definitions/productAudit"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/audit/packaged-product/{id}": {
      "post": {
        "summary": "Audit an existing packaged-product",
        "operationId": "updatePackagedProductAudit",
        "tags": [
          "audit",
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "id of packaged product being audited",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "packaged-product",
            "in": "body",
            "description": "packaged product to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updatePackagedProductAudit"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "packaged-product audit response",
            "schema": {
              "$ref": "#/definitions/packagedProductAudit"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/products": {
      "get": {
        "summary": "Returns all products from the system that the user has access to",
        "operationId": "findProducts",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "search",
            "in": "query",
            "description": "search string for filtering products.  The logic behind this is left up to the implementation, but it should at least match words in the product name, and may optionally match the product description or other characteristics",
            "required": false,
            "type": "string"
          },
          {
            "name": "gtin13",
            "in": "query",
            "description": "packaged-product 13-digit Global Trade Item Numbers to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "brand",
            "in": "query",
            "description": "brand IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "category",
            "in": "query",
            "description": "category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "primary-category",
            "in": "query",
            "description": "primary-category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ancestor-category",
            "in": "query",
            "description": "category IDs to filter by (for products associated with the categories or their descendants)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "tag",
            "in": "query",
            "description": "tags to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by (selects their favorite products)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "person ID for associating additional metadata with results (e.g. whether this person has favorited a given packaged-product).  If unset and you're authenticated, defaults to your authenticated ID",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "product response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/product"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/product/{id}": {
      "get": {
        "summary": "Returns a product based on a single ID, if the user has access to the product",
        "operationId": "findProductById",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of product to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "product response",
            "schema": {
              "$ref": "#/definitions/product"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-products": {
      "get": {
        "summary": "Returns all packaged products from the system that the user has access to",
        "operationId": "findPackagedProduct",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "gtin13",
            "in": "query",
            "description": "13-digit Global Trade Item Numbers to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "brand",
            "in": "query",
            "description": "brand IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "category",
            "in": "query",
            "description": "category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "primary-category",
            "in": "query",
            "description": "primary-category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ancestor-category",
            "in": "query",
            "description": "category IDs to filter by (for packaged products associated with the categories or their descendants)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "tag",
            "in": "query",
            "description": "tags to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by (selects their favorite packaged products)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "person ID for associating additional metadata with results (e.g. whether this person has favorited a given packaged-product).  If unset and you're authenticated, defaults to your authenticated ID",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/packagedProduct"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product/{code}": {
      "get": {
        "summary": "Returns a packaged product based on a single ID, if the user has access to the packaged product",
        "operationId": "findPackagedProductById",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "code of the packaged product to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "product response",
            "schema": {
              "$ref": "#/definitions/packagedProduct"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product-tags": {
      "get": {
        "summary": "Returns all packaged product tags from the system that the user has access to",
        "operationId": "findPackagedProductTag",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "internal",
            "in": "query",
            "description": "if true, only return internal tags (that the user has access to).  If false, only return public tags (regardless of the user's access to internal tags).  If unset, don't filter based on the tag visibility",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "category",
            "in": "query",
            "description": "categories to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product tag response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/packagedProductTag"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product-tag-associations": {
      "get": {
        "summary": "Return packaged product tag filter preferences for a person",
        "operationId": "findPackagedProductTagAssociations",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person ID to filter by",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product tag association response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/packagedProductTagAssociation"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Add a tag to a person's packaged product tag filter preferences",
        "operationId": "addPackagedProductTagAssociation",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "packaged-product-tag-assocation",
            "in": "body",
            "description": "Packaged-product tag association to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/packagedProductTagAssociation"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product tag association response",
            "schema": {
              "$ref": "#/definitions/packagedProductTagAssociation"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product-tag-association/{id}": {
      "delete": {
        "summary": "Delete a packaged product tag association from a person's filter preferences",
        "operationId": "deletePackagedProductTagAssociation",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "packaged product tag association ID to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/categories": {
      "get": {
        "summary": "Returns all categories from the system, ordered by decreasing 'featured' values",
        "operationId": "findCategories",
        "tags": [
          "category"
        ],
        "security": [],
        "parameters": [
          {
            "name": "parent",
            "in": "query",
            "description": "category IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active categories",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/category"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new category",
        "operationId": "createCategory",
        "tags": [
          "category"
        ],
        "parameters": [
          {
            "name": "category",
            "in": "body",
            "description": "Category to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/category"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "$ref": "#/definitions/category"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/category/{id}": {
      "get": {
        "summary": "Returns a category based on a single ID",
        "operationId": "findCategoryById",
        "tags": [
          "category"
        ],
        "security": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of category to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "$ref": "#/definitions/category"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update a category.",
        "operationId": "updateCategory",
        "tags": [
          "category"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of category to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "category",
            "in": "body",
            "description": "Category to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/category"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "$ref": "#/definitions/category"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/purchases": {
      "get": {
        "summary": "Returns all purchases from the system that the user has access to",
        "description": "Purchases are ordered for increasing ID (creation time)",
        "operationId": "findPurchases",
        "tags": [
          "purchase"
        ],
        "parameters": [
          {
            "name": "vendor",
            "in": "query",
            "description": "vendor IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "pickup",
            "in": "query",
            "description": "pickup IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "status",
            "in": "query",
            "description": "purchase-status string to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "open",
                "submitted",
                "confirmed",
                "shipped",
                "delivered",
                "reconciled",
                "paid"
              ]
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "purchase response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/purchase"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you didn't set `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/purchase/{id}": {
      "get": {
        "summary": "Returns a purchase based on a single ID",
        "operationId": "findPurchaseById",
        "tags": [
          "purchase"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of purchase to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "purchase response",
            "schema": {
              "$ref": "#/definitions/purchase"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/orders": {
      "get": {
        "summary": "Returns all orders from the system that the user has access to",
        "operationId": "findOrders",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "username",
            "in": "query",
            "description": "usernames to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "email",
            "in": "query",
            "description": "email addresses to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "format": "email"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "status",
            "in": "query",
            "description": "order-status string to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "open",
                "placed",
                "confirmed",
                "shipped",
                "lost"
              ]
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "order response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/order"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new order",
        "operationId": "addOrder",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "order",
            "in": "body",
            "description": "Order to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateOrder"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order response",
            "schema": {
              "$ref": "#/definitions/order"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order/{id}": {
      "get": {
        "summary": "Returns an order based on a single ID",
        "operationId": "findOrderById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "accept",
            "in": "query",
            "description": "override the HTTP Accept header to chose the response type.  Empty and unrecognized values will result in application/json.",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json",
          "application/pdf",
          "text/csv"
        ],
        "responses": {
          "200": {
            "description": "order response",
            "schema": {
              "$ref": "#/definitions/order"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing order",
        "operationId": "updateOrderById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "order",
            "in": "body",
            "description": "Updated order parameters (can optionally include 'id')",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateOrder"
            }
          },
          {
            "name": "save",
            "in": "query",
            "description": "Whether to save the result of the PUT or not (defaults to true).  Set to false if you want to preview the side-effects of a change before going through with an update",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "Order response",
            "schema": {
              "$ref": "#/definitions/changedOrder"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing order",
        "operationId": "deleteOrder",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order-lines": {
      "get": {
        "summary": "Returns all order-lines from the system that the user has access to",
        "operationId": "findOrderLines",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "order",
            "in": "query",
            "description": "order IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "order-line response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/orderLine"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new order-line",
        "operationId": "addOrderLine",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "order",
            "in": "body",
            "description": "Order-line to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateOrderLine"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order-line response",
            "schema": {
              "$ref": "#/definitions/orderLine"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order-line/{id}": {
      "get": {
        "summary": "Returns an order-line based on a single ID",
        "operationId": "findOrderLineById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order-line to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "order-line response",
            "schema": {
              "$ref": "#/definitions/orderLine"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing order-line",
        "operationId": "updateOrderLine",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order-line to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "order-line",
            "in": "body",
            "description": "Updated order-line parameters (can optionally include 'id')",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateOrderLine"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order-line response",
            "schema": {
              "$ref": "#/definitions/orderLine"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing order-line",
        "operationId": "deleteOrderLine",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order-line to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order-fees": {
      "get": {
        "summary": "Returns all order fees from the system that the user has access to",
        "operationId": "findOrderFees",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "order",
            "in": "query",
            "description": "order IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "order fee response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/orderFee"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order-fee/{id}": {
      "get": {
        "summary": "Returns an order fee based on a single ID",
        "operationId": "findOrderFeeById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order fee to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "order fee response",
            "schema": {
              "$ref": "#/definitions/orderFee"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/vendors": {
      "get": {
        "summary": "Returns all vendors from the system that the user has access to",
        "description": "Vendors are ordered for increasing ID (creation time)",
        "operationId": "findVendors",
        "tags": [
          "vendor"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active vendors",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "manager",
            "in": "query",
            "description": "person IDs to filter by, selecting vendors that these vendor employees manage",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "buyer",
            "in": "query",
            "description": "person IDs to filter by, selecting vendors that these Azure employees buy from",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "vendor response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/vendor"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you didn't set `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/vendor/{id}": {
      "get": {
        "summary": "Returns a vendor based on a single ID",
        "operationId": "findVendorById",
        "tags": [
          "vendor"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of vendor to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "vendor response",
            "schema": {
              "$ref": "#/definitions/vendor"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/account-entries": {
      "get": {
        "summary": "Returns all credits and debits from the system that the user has access to",
        "operationId": "findAccountEntries",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "date-after",
            "in": "query",
            "description": "only return entries with dates after this date (inclusive)",
            "required": false,
            "type": "string",
            "format": "date"
          },
          {
            "name": "date-before",
            "in": "query",
            "description": "only return entries with dates before this date (exclusive)",
            "required": false,
            "type": "string",
            "format": "date"
          },
          {
            "name": "balance",
            "in": "query",
            "description": "add the balance field to returned entries",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "account entry response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/accountEntry"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/account-entry/{id}": {
      "get": {
        "summary": "Returns a credit or debit based on a single ID",
        "operationId": "findAccountEntryById",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of account entry to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "account entry response",
            "schema": {
              "$ref": "#/definitions/accountEntry"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/payments": {
      "post": {
        "summary": "Create a new payment (settled immediately)",
        "operationId": "addPayment",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "payment",
            "in": "body",
            "description": "Payment to create.  Amount and payment-method are both required.",
            "required": true,
            "schema": {
              "$ref": "#definitions/payment"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "account entry response",
            "schema": {
              "$ref": "#/definitions/accountEntry"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/payment-methods": {
      "get": {
        "summary": "Returns all payment methods from the system that the user has access to",
        "description": "Methods associated with a person are ordered by decreasing preference.  The ordering between methods associated with different people is undefined.",
        "operationId": "findPayments",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active payment methods",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "payment method response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/paymentMethod"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new payment method",
        "operationId": "addPaymentMethod",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "payment-method",
            "in": "body",
            "description": "Payment method to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newPaymentMethod"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "payment method response",
            "schema": {
              "$ref": "#/definitions/paymentMethod"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/payment-method/{id}": {
      "get": {
        "summary": "Returns a payment method based on a single ID",
        "operationId": "findPaymentMethodById",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of payment method to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "Payment method response",
            "schema": {
              "$ref": "#/definitions/paymentMethod"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Deactivates a payment method based on a single ID",
        "operationId": "deactivatePaymentMethodById",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of payment method to deactivate",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "deactivate successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/addresses": {
      "get": {
        "summary": "Returns all addresses from the system that the user has access to",
        "description": "Addresses associated with a person are ordered by decreasing preference.  The ordering between addresses associated with different people or (for the same person) with the same preference value is undefined.",
        "operationId": "findAddresses",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include a full representation of the inlined property.  Currently supports \"country\".",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "address response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/address"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new address",
        "operationId": "addAddress",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "address",
            "in": "body",
            "description": "address to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/address"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "address response",
            "schema": {
              "$ref": "#/definitions/address"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/address/{id}": {
      "get": {
        "summary": "Returns a address based on a single ID",
        "operationId": "findAddressById",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of address to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "address response",
            "schema": {
              "$ref": "#/definitions/address"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing address",
        "operationId": "updateAddress",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of address to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "address",
            "in": "body",
            "description": "Address to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/address"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "address response",
            "schema": {
              "$ref": "#/definitions/address"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing address",
        "operationId": "deleteAddress",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of address to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/countries": {
      "get": {
        "summary": "Returns all countries from the system",
        "description": "Countries that are allowed to be used with addresses, ordered by name.",
        "operationId": "findCountries",
        "tags": [
          "country"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "country response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/country"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/regions": {
      "get": {
        "summary": "Returns all country regions from the system",
        "description": "Regions that are allowed to be used with addresses in the United States and Canada, ordered alphabetically.  Other countries may use any string values for their regions.",
        "operationId": "findRegions",
        "tags": [
          "region"
        ],
        "parameters": [
          {
            "name": "country",
            "in": "query",
            "description": "country to filter by",
            "required": false,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "country region response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/region"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/emails": {
      "get": {
        "summary": "Returns all emails from the system that the user has access to.",
        "description": "Emails associated with a person are ordered by decreasing preference.  The ordering between emails associated with different people or (for the same person) with the same preference value is undefined.",
        "operationId": "findEmails",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/email"
              }
            },
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new email.",
        "operationId": "addEmail",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "email",
            "in": "body",
            "description": "Email to add.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateEmailUserPassword"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.  An email with a confirmation URL will be mailed to the address, and new emails will be unconfirmed until the token is submitted via emailConfirmation.",
            "schema": {
              "$ref": "#/definitions/updatedEmail"
            }
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/emails/confirm": {
      "post": {
        "summary": "Complete an in-progress email confirmation.",
        "operationId": "emailConfirmation",
        "tags": [
          "email"
        ],
        "security": [],
        "parameters": [
          {
            "name": "token",
            "in": "body",
            "description": "The confirmation token from addEmail or updateEmail.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.",
            "schema": {
              "$ref": "#/definitions/email"
            }
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/email/{id}": {
      "get": {
        "summary": "Returns a email based on a single ID.",
        "operationId": "findEmailById",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of email to fetch.",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.",
            "schema": {
              "$ref": "#/definitions/email"
            }
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing email.",
        "operationId": "updateEmail",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of email to update.",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "email",
            "in": "body",
            "description": "Email to update.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateEmailUserPassword"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.  If the address changed or the email had an earlier error, an email with a confirmation URL will be mailed to the address.  Changed addresses will be unconfirmed until the token is submitted via emailConfirmation.",
            "schema": {
              "$ref": "#/definitions/updatedEmail"
            }
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing email.",
        "operationId": "deleteEmail",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of email to delete.",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/email/{id}/resend": {
      "post": {
        "summary": "Resend the confirmation email to the user.",
        "operationId": "resendEmailConfirmation",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of email whose confirmation will be re-sent.",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "resend",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/resendRegistrationEmail"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation email re-sent",
            "schema": {}
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/people": {
      "get": {
        "summary": "Returns all people from the system that the user has access to",
        "operationId": "findPeople",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include additional information.  Currently supports \"email\" as described in the email model.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/person"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/person/{id}": {
      "get": {
        "summary": "Returns a person based on a single ID, if the user has access to the person",
        "operationId": "findPersonById",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of person to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include additional information.  Currently supports \"email\" as described in the email model.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing person",
        "operationId": "updatePerson",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of person to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "person",
            "in": "body",
            "description": "Person to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updatePersonUserPassword"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/person": {
      "get": {
        "summary": "Returns the authenticated person (yourself)",
        "operationId": "findPersonByAuth",
        "tags": [
          "person"
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update the authenticated person (yourself)",
        "operationId": "updatePersonByAuth",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "person",
            "in": "body",
            "description": "Person to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updatePersonUserPassword"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/session": {
      "get": {
        "summary": "Returns information about the current cookie-based session",
        "operationId": "findSessionByAuth",
        "tags": [
          "session"
        ],
        "security": [
          {
            "sessionCookie": []
          }
        ],
        "responses": {
          "200": {
            "description": "session response",
            "schema": {
              "$ref": "#/definitions/session"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/login": {
      "post": {
        "summary": "Authenticate and receive a session cookie",
        "operationId": "login",
        "tags": [
          "session"
        ],
        "parameters": [
          {
            "name": "login",
            "in": "body",
            "required": true,
            "type": "object",
            "oneOf": [
              {
                "$ref": "#/definitions/usernamePassword"
              },
              {
                "$ref": "#/definitions/token"
              }
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "session response",
            "schema": {
              "$ref": "#/definitions/session"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/logout": {
      "post": {
        "summary": "Clears the current cookie-based session",
        "operationId": "logout",
        "tags": [
          "session"
        ],
        "security": [
          {
            "sessionCookie": []
          }
        ],
        "responses": {
          "200": {
            "description": "session response",
            "schema": {
              "$ref": "#/definitions/session"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/registration/register": {
      "post": {
        "summary": "Register a new person",
        "description": "When the user provides an email address, check for existing accounts which use that email address.\n\n* If an inactive account using the email address is found, send an inactive-member email pointing the user at customer service.  Do not authenticate the user.\n\n* If an active account using the email address is found, send an active-member email with an authenticating URL with an authentication token.  Following that URL will (possibly indirectly) send the token to this API's login endpoint to authenticate the bearer.\n\n* If no account using that email address is found, create a new account and immediately authenticate the user.  If they provided an email address or SMS number, potentially send a welcome-aboard notification.  Any email address will remain unconfirmed until the user completes a confirmation cycle.",
        "operationsId": "registerPerson",
        "tags": [
          "registration"
        ],
        "parameters": [
          {
            "name": "registration",
            "in": "body",
            "required": true,
            "type": "object",
            "schema": {
              "$ref": "#/definitions/registrationRequest"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include a full representation of the inlined property. Currently supports \"session.person\" and descendants.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          }
        ],
        "responses": {
          "200": {
            "description": "registration request response",
            "schema": {
              "$ref": "#/definitions/registrationResponse"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/registration/resend": {
      "post": {
        "summary": "Resend the confirmation email to the user",
        "operationId": "resendRegistrationEmail",
        "tags": [
          "registration"
        ],
        "parameters": [
          {
            "name": "resend",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/resendRegistrationEmail"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation email re-sent",
            "schema": {}
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/password/reset": {
      "post": {
        "summary": "Initiate a password reset, to be completed by a call to /password/confirm",
        "operationId": "resetPasswordRequest",
        "tags": [
          "password"
        ],
        "parameters": [
          {
            "name": "reset",
            "in": "body",
            "required": true,
            "type": "object",
            "schema": {
              "$ref": "#/definitions/passwordResetRequest"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Password-reset email sent (if the registration email corresponded to an existing person.  Otherwise, you'll still get a 204 to avoid leaking information about member email addresses)"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/password/confirm": {
      "post": {
        "summary": "Complete an in-progress password reset",
        "operationId": "passwordResetConfirmation",
        "tags": [
          "password"
        ],
        "parameters": [
          {
            "name": "reset",
            "in": "body",
            "description": "The registrant's confirmation token",
            "required": true,
            "type": "object",
            "schema": {
              "$ref": "#/definitions/passwordResetConfirmation"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/notifications": {
      "get": {
        "summary": "Returns all notifications from the system that the user has access to",
        "operationId": "findNotifications",
        "tags": [
          "notification"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active notifications",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "add a boolean dismissed field to the results with whether or not the annotate-person has dismissed this notification, required with dismissed",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "dismissed",
            "in": "query",
            "description": "only return notifications that are (not) dismissed by the annotate-person",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "notification response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/notification"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/notification-dismissals": {
      "post": {
        "summary": "Create a notification dismissal (a user may only dismiss notifications for himself)",
        "operationId": "addNotificationDismissal",
        "tags": [
          "notification"
        ],
        "parameters": [
          {
            "name": "notification-dismissal",
            "in": "body",
            "description": "Notification dismissal to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/notificationDismissal"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "notification dismissal response",
            "schema": {
              "$ref": "#/definitions/notificationDismissal"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/favorites": {
      "get": {
        "summary": "Returns a list of all customer's packaged product favorites",
        "operationId": "findFavorites",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "active",
            "in": "query",
            "description": "only return favorites associated with (in)active packaged products.  For example, we sometimes discontinue products and then pick them back up later.  In this context, \"active\" means \"for sale to at least some customers\".",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include a full representation of the inlined property. Currently supports \"packaged-product\" and \"packaged-product.product\".",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "array of favorites response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/favorite"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Creates and returns a customer favorite",
        "operationId": "addFavorite",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "favorite",
            "in": "body",
            "description": "favorite to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFavorite"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "favorite response",
            "schema": {
              "$ref": "#/definitions/favorite"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/favorite/{id}": {
      "get": {
        "summary": "Returns a single customer favorite",
        "operationId": "findFavoriteById",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of favorite to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "favorite response",
            "schema": {
              "$ref": "#/definitions/favorite"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Updates and returns a customer favorite",
        "operationId": "updateFavorite",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of favorite to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "favorite",
            "in": "body",
            "description": "Favorite to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFavorite"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "favorite response",
            "schema": {
              "$ref": "#/definitions/favorite"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      },
      "delete": {
        "summary": "Deletes a customer favorite",
        "operationId": "deleteFavorite",
        "tags": [
          "favorite"
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/faqs": {
      "get": {
        "summary": "Returns a list of frequently asked questions and answers",
        "operationId": "getFaqs",
        "tags": [
          "faq"
        ],
        "perameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "array of faq response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/faq"
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Creates and returns a faq",
        "operationId": "addFaq",
        "tags": [
          "faq"
        ],
        "parameters": [
          {
            "name": "faq",
            "in": "body",
            "description": "faq to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFaq"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "faq response",
            "schema": {
              "$ref": "#/definitions/faq"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/faq/{id}": {
      "get": {
        "summary": "Returns a single faq",
        "operationId": "getFaqById",
        "tags": [
          "faq"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of faq to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "faq response",
            "schema": {
              "$ref": "#/definitions/faq"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Updates and returns a faq",
        "operationId": "updateFaq",
        "tags": [
          "faq"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of faq to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "faq",
            "in": "body",
            "description": "Faq to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFaq"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "faq response",
            "schema": {
              "$ref": "#/definitions/faq"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      },
      "delete": {
        "summary": "Deletes a faq",
        "operationId": "deleteFaq",
        "tags": [
          "faq"
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/printers": {
      "get": {
        "summary": "Returns all printers from the system that the user has access to",
        "operationId": "findPrinters",
        "tags": [
          "printer"
        ],
        "parameters": [
          {
            "name": "delivery",
            "in": "query",
            "description": "printer delivery method",
            "required": false,
            "type": "array",
            "items": {
              "$ref": "#/definitions/printerDeliveryType"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "format",
            "in": "query",
            "description": "printer format",
            "required": false,
            "type": "array",
            "items": {
              "$ref": "#/definitions/printerFormatType"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "printer response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/printer"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/printer/{id}": {
      "get": {
        "summary": "Returns a printer based on a single ID, if the user has access to it",
        "operationId": "findPrinterById",
        "tags": [
          "printer"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of printer to fetch",
            "required": true,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "printer response",
            "schema": {
              "$ref": "#/definitions/printer"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/warehouses": {
      "get": {
        "summary": "Returns all warehouses from the system that the user has access to",
        "operationId": "findWarehouses",
        "tags": [
          "warehouse"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "warehouse response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/warehouse"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/warehouse/{code}": {
      "get": {
        "summary": "Returns a warehouse based on a single code, if the user has access to it",
        "operationId": "findWarehouseByCode",
        "tags": [
          "warehouse"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "code of warehouse to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "warehouse response",
            "schema": {
              "$ref": "#/definitions/warehouse"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/ip2location": {
      "get": {
        "summary": "Returns location data for the requesting ip address.",
        "operationId": "ip2Location",
        "parameters": [
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include a full representation of the inlined property.  Currently supports \"address.country\".",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          }
        ],
        "responses": {
          "200": {
            "description": "ip2location response",
            "schema": {
              "$ref": "#/definitions/ip2location"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "bartenderHost": {
      "description": "a BarTender host/instance",
      "type": "object",
      "properties": {
        "code": {
          "description": "slug for stable reference (e.g. \"bt1\")",
          "type": "string"
        },
        "name": {
          "description": "human readable name (e.g. \"Bar Tender 1\")",
          "type": "string"
        }
      },
      "required": [
        "code",
        "name"
      ]
    },
    "bartenderTemplate": {
      "description": "a BarTender template/document",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "path": {
          "description": "Path to the BarTender template on the BarTender host filesystem.",
          "type": "string"
        }
      },
      "required": [
        "id",
        "path"
      ]
    },
    "bartenderPrintConfiguration": {
      "description": "A BarTender print configuration for BarTender print requests.  These configurations are added to warehouse pieces (which are related to individual stock) in Beehive and are used to route print requests and to tell BarTender which template should be used.  A print request will be created for each print configuration associated with a stock location's warehouse.",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "host": {
          "description": "the BarTender host's code",
          "type": "string"
        },
        "printer": {
          "description": "The printer ID. The referenced printer must support the `bartender` format and delivery methods.",
          "type": "integer",
          "format": "int64"
        },
        "template": {
          "description": "The BarTender template ID.",
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "id",
        "host",
        "printer",
        "template"
      ]
    },
    "drop": {
      "description": "an order-delivery location",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "coordinators": {
          "description": "coordinators for this drop.  The first entry is the primary contact",
          "type": "array",
          "items": {
            "description": "person ID for this coordinator",
            "type": "integer",
            "format": "int32"
          }
        },
        "address": {
          "$ref": "#/definitions/address"
        },
        "geo": {
          "$ref": "#/definitions/geo"
        },
        "active": {
          "description": "whether or not this drop is actively ordering",
          "type": "boolean"
        },
        "accounts-payable-contact": {
          "description": "name of the drop employee Azure's accounts-payable should contact, if different from the primary contact",
          "type": "string"
        },
        "after-hours-phone": {
          "description": "E.123 telephone number Azure should call if we need to contact the drop after business hours",
          "type": "string"
        },
        "business-hours": {
          "description": "regular business hours for the drop (e.g. \"8:30-6 Mon-Fri, 9-5 Sat, closed Sun\")",
          "type": "string"
        },
        "business-type": {
          "description": "what type of business do you run?",
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "clinics-practitioner",
              "manufacturing-business",
              "online-store",
              "restaurant",
              "retail-store",
              "seasonal",
              "wholesale-distributor"
            ]
          }
        },
        "buyer": {
          "description": "name of the drop employee who usually places orders for this drop, if different from the primary contact",
          "type": "string"
        },
        "pickup-contact": {
          "description": "do customers need to contact you to pick up their orders?  Retail preference.  Only available when how-members-receive is \"can-hold-sometimes\" or \"can-hold\"",
          "type": "string",
          "enum": [
            "yes",
            "no",
            "first-time-only"
          ]
        },
        "contact-person": {
          "type": "string"
        },
        "contact-type": {
          "description": "how can customers contact you?",
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "phone",
              "email",
              "other"
            ]
          }
        },
        "contact-type-other-notes": {
          "description": "description of the alternative contact method.  Available when contact-type includes \"other\"",
          "type": "string"
        },
        "contact-type-phone": {
          "description": "E.123 telephone number customers should call to contact this drop.  Available when contact-type includes \"phone\"",
          "type": "string"
        },
        "directions": {
          "description": "driving directions for a truck approaching this drop (e.g. avoiding low bridges, tight turns, etc. on more obvious routes)",
          "type": "string"
        },
        "driver-callable-phone": {
          "description": "E.123 telephone number for a driver approaching this drop",
          "type": "string"
        },
        "exclusivity": {
          "type": "string",
          "enum": [
            "open",
            "semi-open",
            "closed"
          ]
        },
        "food-stamps": {
          "description": "does your drop accept food stamps?  Business preference.",
          "type": "string",
          "enum": [
            "yes",
            "no",
            "limited"
          ]
        },
        "food-stamps-limited-notes": {
          "description": "description of limited food-stamp acceptance.  Business preference.  Only available when food-stamps is \"limited\"",
          "type": "string"
        },
        "hold-time": {
          "description": "how long will you hold a customer's order?  For example, \"24 hours\", \"three days for dry, frozen by arrangement\", etc.  Retail preference.  Only available when how-members-receive is \"can-hold-sometimes\" or \"can-hold\"",
          "type": "string"
        },
        "how-members-receive": {
          "description": "how do your members receive their items?  Retail preference",
          "type": "string",
          "enum": [
            "must-show",
            "can-hold-sometimes",
            "can-hold"
          ]
        },
        "invoice-always": {
          "description": "always print paper invoices, regardless of the customer's invoice-delivery preference",
          "type": "boolean"
        },
        "okay-to-text-phone": {
          "description": "can the driver send text messages to the driver-callable phone?",
          "type": "boolean"
        },
        "parking": {
          "description": "parking location ownership for this drop",
          "type": "string",
          "enum": [
            "home",
            "business",
            "non-profit",
            "public",
            "other-building"
          ]
        },
        "special-orders": {
          "description": "do you take special orders for Azure products from customers?  Wholesale preference",
          "type": "boolean"
        },
        "storage": {
          "description": "storage environments available at this drop",
          "type": "array",
          "items": {
            "$ref": "#/definitions/storage"
          }
        },
        "fees": {
          "$fees": "#definitions/dropFees"
        },
        "order-minimum": {
          "description": "the minimum total order value (in dollars) required to ship a particular trip to this drop.  For example, if the minimum is $400 and there are three $100 orders placed for a stop, that stop will be under-minimum, and the orders will not be shipped.  If, on the other hand, there were four $100 orders placed for a stop, that stop would be (just) over-minimum, and the orders would be shipped.",
          "type": "number",
          "format": "float"
        },
        "members": {
          "description": "number of customers on this drop",
          "type": "integer",
          "format": "int32"
        },
        "order-frequency": {
          "description": "order counts for this drop over the past year",
          "type": "object",
          "properties": {
            "orders": {
              "description": "count of orders for this route-trip-drop",
              "type": "integer",
              "format": "int32"
            },
            "cutoff": {
              "description": "cutoff date for this route-trip",
              "type": "string",
              "format": "date"
            }
          }
        },
        "notes": {
          "description": "free-form Markdown notes for any drop information that doesn't fit into an existing field",
          "type": "string"
        },
        "sells-finished-goods-to-azure": {
          "description": "do you also sell your finished good to Azure?  Only available if business-type includes \"manufacturing-business\"",
          "type": "boolean"
        },
        "uses-azure-to-drop-ship": {
          "description": "Do you drop ship Azure orders (have Azure ship directly to your customers)?  Only available if business-type includes \"online-store\"",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "name",
        "geo",
        "active",
        "exclusivity",
        "members"
      ]
    },
    "newDrop": {
      "$ref": "drop"
    },
    "updateDrop": {
      "description": "an order-delivery location",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "address": {
          "$ref": "#/definitions/address"
        },
        "geo": {
          "description": "recalculated from address if not included",
          "$ref": "#/definitions/geo"
        },
        "active": {
          "description": "whether or not this drop is actively ordering",
          "type": "boolean"
        },
        "parking": {
          "description": "parking location ownership for this drop",
          "type": "string",
          "enum": [
            "home",
            "business",
            "non-profit",
            "public"
          ]
        },
        "storage": {
          "description": "storage environments available at this drop",
          "type": "array",
          "items": {
            "$ref": "#/definitions/storage"
          }
        },
        "fees": {
          "$fees": "#definitions/dropFees"
        },
        "notes": {
          "description": "free-form Markdown notes for any drop information that doesn't fit into an existing field",
          "type": "string"
        }
      },
      "required": [
        "name",
        "active"
      ]
    },
    "dropFees": {
      "description": "additional costs for members receiving at a drop",
      "type": "object",
      "properties": {
        "medium": {
          "description": "payment medium (nothing, volunteer time, or a monetary payment)",
          "type": "string",
          "enum": [
            "volunteer",
            "payment"
          ]
        },
        "condition": {
          "description": "fee trigger (never, only when orders are held, or for every order)",
          "type": "string",
          "enum": [
            "held",
            "order"
          ]
        },
        "notes": {
          "description": "fee amount and structure",
          "type": "string"
        }
      }
    },
    "dropMembership": {
      "description": "a drop membership",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "customer": {
          "description": "customer that has the drop membership",
          "type": "integer",
          "format": "int64"
        },
        "drop": {
          "description": "the drop this membership is for",
          "type": "integer",
          "format": "int64"
        },
        "active": {
          "description": "whether or not this membership is active.  Pending memberships are active, and the usual flow for semi-open drops is (active true, pending true) -> (active true, pending false) -> (active false, pending false).",
          "type": "boolean"
        },
        "pending": {
          "description": "whether the membership is pending (true) or accepted (false).",
          "type": "boolean"
        },
        "created": {
          "description": "date-time the drop-membership was created",
          "type": "string",
          "format": "date-time"
        },
        "heavy": {
          "description": "whether the member can get pallets, totes, barrels, and other heavy objects off a truck (defaults to false).",
          "type": "boolean"
        },
        "notifications": {
          "$ref": "#/definitions/dropMembershipNotifications"
        }
      },
      "required": [
        "id",
        "customer",
        "drop",
        "active",
        "pending",
        "created",
        "notifications"
      ]
    },
    "updateDropMembership": {
      "description": "a drop membership to update",
      "type": "object",
      "properties": {
        "customer": {
          "description": "customer that has the drop membership",
          "type": "integer",
          "format": "int64"
        },
        "drop": {
          "description": "the drop this membership is for",
          "type": "integer",
          "format": "int64"
        },
        "active": {
          "description": "whether or not this membership is active.",
          "type": "boolean"
        },
        "pending": {
          "description": "whether the membership is pending (true) or accepted (false).",
          "type": "boolean"
        },
        "heavy": {
          "description": "whether the member can get pallets, totes, barrels, and other heavy objects off a truck (defaults to false).",
          "type": "boolean"
        },
        "notifications": {
          "$ref": "#/definitions/dropMembershipNotifications"
        }
      },
      "required": [
        "customer",
        "drop",
        "active"
      ]
    },
    "newDropMembership": {
      "$ref": "updateDropMembership"
    },
    "dropMembershipNotifications": {
      "description": "configure if and how a user receives per-drop notifications",
      "type": "object",
      "properties": {
        "cutoff": {
          "description": "receive notifications from Azure before cutoffs for this drop.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        }
      }
    },
    "pickup": {
      "description": "a purchase-pickup location",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "vendors": {
          "description": "vendors supplying this pickup",
          "type": "array",
          "items": {
            "description": "vendor ID",
            "type": "integer",
            "format": "int32"
          }
        },
        "address": {
          "$ref": "#/definitions/address"
        },
        "geo": {
          "$ref": "#/definitions/geo"
        },
        "active": {
          "description": "whether or not this pickup is actively supplying purchases",
          "type": "boolean"
        },
        "notes": {
          "description": "free-form Markdown notes for any pickup information that doesn't fit into an existing field",
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "vendors",
        "address",
        "geo",
        "active"
      ]
    },
    "route": {
      "description": "an order-delivery truck route",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "cutoff-frequency": {
          "description": "number of days between cutoffs",
          "type": "integer",
          "format": "int32"
        },
        "delivery-offset": {
          "description": "number of days after cutoff before the first stop",
          "type": "integer",
          "format": "int32"
        },
        "internal": {
          "description": "Is the route for internal use? This controls whether customers can access the route via the API (they can't if internal is true).",
          "type": "boolean"
        },
        "backhaul-cost-per-pound": {
          "description": "route backhaul cost per pound",
          "type": "number",
          "format": "float"
        },
        "backhaul-cost-per-pickup": {
          "description": "route backhaul cost per pickup",
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "name",
        "cutoff-frequency",
        "delivery-offset",
        "internal"
      ]
    },
    "updateRoute": {
      "description": "an order-delivery truck route's updated values",
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "cutoff-frequency": {
          "description": "number of days between cutoffs",
          "type": "integer",
          "format": "int32"
        },
        "delivery-offset": {
          "description": "number of days after cutoff before the first stop",
          "type": "integer",
          "format": "int32"
        },
        "internal": {
          "description": "Is the route for internal use? This controls whether customers can access the route via the API (they can't if internal is true).",
          "type": "boolean"
        },
        "backhaul-cost-per-pound": {
          "description": "route backhaul cost per pound",
          "type": "number",
          "format": "float"
        },
        "backhaul-cost-per-pickup": {
          "description": "route backhaul cost per pickup",
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "cutoff-frequency",
        "delivery-offset",
        "internal"
      ]
    },
    "newRoute": {
      "$ref": "route"
    },
    "trip": {
      "description": "a truck delivering orders along a route",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "route": {
          "description": "name of the followed route",
          "type": "string"
        },
        "cutoff": {
          "description": "cutoff for placing orders on this trip",
          "type": "string",
          "format": "date-time"
        },
        "confirmed": {
          "description": "when the trip was reviewed and orders were either accepted or (for short drops) bumped to the next trip.  This will always be set before the trip is confirmed, and will be unset until then.  Customer service and customers who have received a short-drop notification can continue to manipulate placed orders in the window between cutoff and confirmation.",
          "type": "string",
          "format": "date-time"
        },
        "pick-date": {
          "description": "date-time that orders for this trip should be picked",
          "type": "string",
          "format": "date-time"
        },
        "shipped": {
          "description": "approximately when the truck left the warehouse.  This will always be set after the truck has left, and will be unset until then.",
          "type": "string",
          "format": "date-time"
        },
        "delivery-start": {
          "description": "estimated stop-time for the first stop",
          "type": "string",
          "format": "date-time"
        },
        "delivery-end": {
          "description": "estimated stop-time for the last stop",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-start": {
          "description": "estimated date-time for the first backhaul",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-end": {
          "description": "estimated date-time for the last backhaul",
          "type": "string",
          "format": "date-time"
        },
        "warehouse-arrival": {
          "description": "estimated date-time for warehouse arrival",
          "type": "string",
          "format": "date-time"
        },
        "notes": {
          "description": "free-form Markdown notes for additional trip information.  We expect this will mostly be for delay causes (e.g. \"High winds in Laramie\" or \"The truck broke down\")",
          "type": "string"
        }
      },
      "required": [
        "id",
        "route",
        "cutoff",
        "delivery-start"
      ]
    },
    "updateTrip": {
      "description": "a truck delivering orders along a route to be updated",
      "type": "object",
      "properties": {
        "route": {
          "description": "name of the followed route",
          "type": "string"
        },
        "cutoff": {
          "description": "cutoff for placing orders on this trip",
          "type": "string",
          "format": "date-time"
        },
        "pick-date": {
          "description": "date-time that orders for this trip should be picked",
          "type": "string",
          "format": "date-time"
        },
        "delivery-start": {
          "description": "estimated stop-time for the first stop",
          "type": "string",
          "format": "date-time"
        },
        "delivery-end": {
          "description": "estimated stop-time for the last stop",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-start": {
          "description": "estimated date-time for the first backhaul",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-end": {
          "description": "estimated date-time for the last backhaul",
          "type": "string",
          "format": "date-time"
        },
        "warehouse-arrival": {
          "description": "estimated date-time for warehouse arrival",
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "route",
        "cutoff",
        "delivery-start"
      ]
    },
    "routeStop": {
      "description": "a template used to create stops when a trip is created",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "route": {
          "description": "route name for the route-stop",
          "type": "string"
        },
        "drop": {
          "description": "drop ID for the route-stop",
          "type": "integer",
          "format": "int64"
        },
        "delivery-offset": {
          "description": "offset from midnight on the morning of the trips's delivery start until the usual delivery time for this drop",
          "type": "string",
          "format": "duration"
        }
      },
      "required": [
        "id",
        "route",
        "drop",
        "target-time",
        "estimated-time"
      ]
    },
    "stop": {
      "description": "a trip stop or waypoint.  Stops are created for all route-stops when a trip is created for that route.  At confirmation time, stops that will not be visited (e.g. because they missed their order-minimum) are deleted",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "trip": {
          "description": "trip ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "drop": {
          "description": "drop ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "short-drop": {
          "description": "whether short-drop warnings were sent out for this stop.  If they were, customers can manipulate placed orders after cutoff time, although nobody can edit orders after the trip is confirmed.",
          "type": "boolean"
        },
        "pickup": {
          "description": "pickup ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "timezone": {
          "description": "IANA time zone location (https://www.iana.org/time-zones, e.g. America/Los_Angeles)",
          "type": "string"
        },
        "target-time": {
          "description": "planned stop time (fixed before the trip starts)",
          "type": "string",
          "format": "date-time"
        },
        "estimated-time": {
          "description": "estimated stop time (updated after the trip starts until the stop is reached)",
          "type": "string",
          "format": "date-time"
        },
        "time": {
          "description": "actual stop time (set after the stop is reached)",
          "type": "string",
          "format": "date-time"
        },
        "verified": {
          "description": "whether the stop is verified or not",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "trip",
        "target-time",
        "estimated-time"
      ]
    },
    "updateStop": {
      "description": "an update to a trip stop or waypoint",
      "type": "object",
      "properties": {
        "trip": {
          "description": "trip ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "drop": {
          "description": "drop ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "pickup": {
          "description": "pickup ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "target-time": {
          "description": "planned stop time (fixed before the trip starts)",
          "type": "string",
          "format": "date-time"
        },
        "estimated-time": {
          "description": "estimated stop time (updated after the trip starts until the stop is reached)",
          "type": "string",
          "format": "date-time"
        },
        "time": {
          "description": "actual stop time (set after the stop is reached)",
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "trip",
        "target-time",
        "estimated-time"
      ]
    },
    "storage": {
      "description": "An environment for storing products",
      "type": "string",
      "enum": [
        "dry",
        "chilled",
        "frozen",
        "greenhouse"
      ]
    },
    "packagedProduct": {
      "description": "a particular packaged form of a product",
      "type": "object",
      "properties": {
        "code": {
          "type": "string"
        },
        "gtin13": {
          "description": "13-digit Global Trade Item Number (https://schema.org/gtin13)",
          "type": "string"
        },
        "size": {
          "description": "size of the product (e.g. 12 oz., or 6x12 oz.)",
          "type": "string"
        },
        "weight": {
          "minimum": {
            "description": "minimum weight of this packaged product in pounds",
            "type": "number",
            "format": "float"
          },
          "maximum": {
            "description": "maximum weight of this packaged product in pounds",
            "type": "number",
            "format": "float"
          },
          "average": {
            "description": "an estimate of the average weight of this packaged product in pounds",
            "type": "number",
            "format": "float"
          }
        },
        "volume": {
          "description": "volume of this packaged product in cubic feet",
          "type": "number",
          "format": "float"
        },
        "price": {
          "#ref": "#/definitions/price"
        },
        "stock": {
          "description": "amount of stock available for purchase.  This includes breakdown ancestors.  For example, if we have a single 4 x 6 x 14 oz case in the warehouse, the 4 x 6 x 14 oz packaging will have 1 stock, the 6 x 14 oz packagaging will have 4 stock, and the 14 oz packaging will have 24 stock.",
          "type": "integer",
          "format": "int32"
        },
        "favorite": {
          "description": "if the annotate-person you associated with the request has favorited this packaged product",
          "type": "boolean"
        },
        "favorites": {
          "description": "number of people who've marked this packaged product as a favorite",
          "type": "integer",
          "format": "int32"
        },
        "images": {
          "type": "array",
          "items": {
            "description": "URL for a picture of this packaged product",
            "type": "string"
          }
        },
        "tags": {
          "description": "Mark types for this packaged product",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "bargain-bin-notes": {
          "description": "Bargain-bin notes for this packaged product",
          "type": "string"
        },
        "product": {
          "description": "the name and brand of the product that this packaged-product is associated with",
          "schema": {
            "$ref": "#/definitions/packagedProductProduct"
          }
        },
        "primary-category": {
          "description": "the id of the primary category for this packaged-product",
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "code",
        "size",
        "price",
        "tags"
      ]
    },
    "packagedProductProduct": {
      "description": "the ID, name, and brand of a product that a packaged-product is associated with",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "the product name",
          "type": "string"
        },
        "brand": {
          "description": "the brand that this product is associated with",
          "schema": {
            "$ref": "#/definitions/brand"
          }
        }
      }
    },
    "packagedProductTag": {
      "description": "a type of packaged product or other boolean marker",
      "type": "object",
      "properties": {
        "slug": {
          "description": "code used as the primary key for tags",
          "type": "string"
        },
        "name": {
          "description": "human-readable tag name",
          "type": "string"
        },
        "category": {
          "description": "category code describing the type of tag",
          "type": "string",
          "enum": [
            "status",
            "price-level",
            "characteristic"
          ]
        }
      }
    },
    "packagedProductTagAssociation": {
      "description": "a packaged product tag representing a saved filter for a person",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "person": {
          "type": "integer",
          "format": "int64"
        },
        "tag": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "person",
        "tag"
      ]
    },
    "product": {
      "description": "a product available for sale (independent of packaging)",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "sentence-length product name",
          "type": "string"
        },
        "description": {
          "description": "long-form product description",
          "type": "string"
        },
        "brand": {
          "$ref": "#/definitions/brand"
        },
        "directions": {
          "description": "product use directions (e.g., cooking suggestions)",
          "type": "string"
        },
        "favorites": {
          "description": "number of people who've marked this product as a favorite",
          "type": "integer",
          "format": "int32"
        },
        "ingredients": {
          "description": "ingredients used in this product (e.g., \"dried cranberries (organic cranberries, organic cane sugar, organic sunflower oil)\")",
          "type": "string"
        },
        "nutrition-facts": {
          "$ref": "#/definitions/nutritionFacts"
        },
        "packaging": {
          "description": "packaged versions of this product",
          "type": "array",
          "items": {
            "$ref": "#/definitions/packagedProduct"
          }
        },
        "country-of-origin": {
          "description": "country of origin for this product",
          "type": "string"
        },
        "storage": {
          "description": "The environment in which this product must be stored",
          "$ref": "#/definitions/storage"
        },
        "slug": {
          "description": "a slug generated from the product name",
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "size",
        "price",
        "packaging"
      ]
    },
    "nutritionFacts": {
      "description": "nutrition facts",
      "type": "object",
      "properties": {
        "headers": {
          "description": "nutrition-fact headers (e.g. \"Serving Size 1 cake (19g)\" or \"Calories 60\")",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "daily-values": {
          "description": "nutrition facts daily values",
          "type": "array",
          "items": {
            "$ref": "#/definitions/nutritionFactsDailyValue"
          }
        }
      }
    },
    "nutritionFactsDailyValue": {
      "description": "a nutrition facts daily value",
      "type": "object",
      "properties": {
        "indent": {
          "description": "if true, this label should be indented (e.g. an indented \"Dietary Fiber\" entry might follow a non-indented \"Total Carbohydrate\" entry)",
          "type": "boolean"
        },
        "label": {
          "description": "daily value label (e.g. \"Total Carbohydrate 14g\", \"Calcium\")",
          "type": "string"
        },
        "percentage": {
          "description": "daily value percentage (e.g., \"10\" or \"<1\")",
          "type": "string"
        }
      },
      "required": [
        "indent",
        "label",
        "percentage"
      ]
    },
    "brand": {
      "description": "a brand which may be associated with several products",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "url": {
          "description": "homepage for the brand",
          "type": "string",
          "format": "url"
        },
        "slug": {
          "description": "a slug generated from the brand name",
          "type": "string"
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "_price": {
      "description": "a helper object for 'price'",
      "type": "object",
      "properties": {
        "dollars": {
          "description": "price of the product in dollars",
          "type": "number",
          "format": "float"
        },
        "per-pound": {
          "description": "whether the 'dollars' price is per-pound or per-product",
          "type": "boolean"
        },
        "discount": {
          "description": "text for the discount (e.g. \"12%\", or \"$3.50\")",
          "type": "string"
        },
        "dollars-per-unit": {
          "description": "the per-unit price",
          "type": "number",
          "format": "float"
        },
        "unit": {
          "description": "The unit for the dollars-per-unit",
          "type": "string"
        }
      },
      "required": [
        "dollars"
      ]
    },
    "priceLevel": {
      "description": "a customer property to pick the right price from 'price'",
      "type": "string",
      "enum": [
        "retail",
        "wholesale",
        "member"
      ]
    },
    "permission": {
      "description": "an API authorization or authorization category",
      "type": "string",
      "enum": [
        "staff",
        "superuser"
      ]
    },
    "price": {
      "description": "product price information",
      "type": "object",
      "properties": {
        "retail": {
          "description": "pricing for retail customers",
          "schema": {
            "$ref": "#/definitions/_price"
          }
        },
        "wholesale": {
          "description": "pricing for wholesale customers",
          "schema": {
            "$ref": "#/definitions/_price"
          }
        },
        "member": {
          "description": "pricing for member customers",
          "schema": {
            "$ref": "#/definitions/_price"
          }
        }
      }
    },
    "category": {
      "description": "a category available for sale",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "A phrase naming the category.  This should be understandable (but not necessarily unique) without any further context.  It must be unique for categories sharing a given parent.",
          "type": "string"
        },
        "short-name": {
          "description": "A word or two naming the category.  A shortened version of the full name that drops any words already contained in the category's ancestors' short names.  This will be used in places where the ancestor short names are in close proximity (e.g. URL slugs) to avoid having the same word many times.",
          "type": "string"
        },
        "image": {
          "description": "A picture of this category.  Use base64 to upload new images, and leave unset to delete an existing image.  Invalid base64, including URLs containing colons and/or periods, will result in no change.",
          "type": "string"
        },
        "parent": {
          "description": "category ID for the parent category",
          "type": "integer",
          "format": "int64"
        },
        "primary": {
          "description": "denotes if this is a primary category",
          "type": "boolean"
        },
        "active": {
          "description": "denotes if this category is active",
          "type": "boolean"
        },
        "keywords": {
          "type": "array",
          "items": {
            "description": "a keyword for this category",
            "type": "string"
          }
        },
        "featured": {
          "description": "ordering precedence for likely customer interest.  Defaults to zero.",
          "type": "integer",
          "format": "int32"
        },
        "slug": {
          "description": "a slug generated from the category short-name (or name if short-name is not defined)",
          "type": "string"
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "purchase": {
      "description": "a purchase order placed by Azure",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "vendor": {
          "description": "vendor supplying the order",
          "type": "integer",
          "format": "int64"
        },
        "status": {
          "description": "purchase's lifecycle stage",
          "type": "string",
          "enum": [
            "open",
            "submitted",
            "confirmed",
            "shipped",
            "delivered",
            "labeled",
            "reconciled",
            "paid"
          ]
        },
        "submitted": {
          "description": "when the purchase was submitted",
          "type": "string",
          "format": "date-time"
        },
        "confirmed": {
          "description": "when the purchase was confirmed",
          "type": "string",
          "format": "date-time"
        },
        "delivered": {
          "description": "when the purchase was delivered",
          "type": "string",
          "format": "date-time"
        },
        "reconciled": {
          "description": "when the purchase was reconciled",
          "type": "string",
          "format": "date-time"
        },
        "pickup": {
          "description": "drop the purchase is destined for (only set for backhaul purchases)",
          "type": "integer",
          "format": "int64"
        },
        "trip": {
          "description": "trip delivering the purchase (only set for backhaul purchases)",
          "type": "integer",
          "format": "int64"
        },
        "notes": {
          "description": "free-form Markdown notes for any purchase information that doesn't fit into an existing field",
          "type": "string"
        }
      },
      "required": [
        "id",
        "vendor",
        "status"
      ]
    },
    "order": {
      "description": "an order placed by a customer",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "customer": {
          "description": "customer making the order",
          "type": "integer",
          "format": "int64"
        },
        "status": {
          "description": "order's lifecycle stage",
          "type": "string",
          "enum": [
            "open",
            "placed",
            "confirmed",
            "shipped",
            "lost"
          ]
        },
        "placed": {
          "description": "when the order was placed",
          "type": "string",
          "format": "date-time"
        },
        "shipped": {
          "description": "when the order was shipped",
          "type": "string",
          "format": "date-time"
        },
        "target-delivery": {
          "description": "planned delivery time (fixed before the trip starts, and unset for parcel-carrier orders)",
          "type": "string",
          "format": "date-time"
        },
        "estimated-delivery": {
          "description": "estimated delivery time (updated after the trip starts until the order is delivered, and unset for parcel-carrier orders)",
          "type": "string",
          "format": "date-time"
        },
        "delivered": {
          "description": "when the order was delivered",
          "type": "string",
          "format": "date-time"
        },
        "checkout-payment": {
          "description": "before shipping, the customer can use this to associate a payment-method with the order.  After shipping, it contains information about the charged payment",
          "$ref": "#/definitions/payment"
        },
        "drop": {
          "description": "drop the order is destined for (unset for parcel-carrier orders)",
          "type": "integer",
          "format": "int64"
        },
        "trip": {
          "description": "trip delivering the order (automatically populated for parcel-carrier orders)",
          "type": "integer",
          "format": "int64"
        },
        "address": {
          "description": "parcel-carrier delivery location (unset for truck orders)",
          "$ref": "#/definitions/address"
        },
        "cases-shipped": {
          "description": "Quantity of shipped boxes and bulk stock",
          "$ref": "#/definitions/orderCases"
        },
        "notes": {
          "description": "Warehouse packing instructions",
          "type": "string"
        }
      },
      "required": [
        "id",
        "customer",
        "status"
      ]
    },
    "updateOrder": {
      "description": "an order placed by a customer",
      "type": "object",
      "properties": {
        "customer": {
          "description": "customer making the order",
          "type": "integer",
          "format": "int64"
        },
        "status": {
          "description": "order's lifecycle stage",
          "type": "string",
          "enum": [
            "open",
            "placed",
            "shipped",
            "lost"
          ]
        },
        "checkout-payment": {
          "description": "before shipping, the customer can use this to associate a payment-method with the order.  After shipping, it contains information about the charged payment",
          "$ref": "#/definitions/payment"
        },
        "drop": {
          "description": "drop the order is destined for (unset for parcel-carrier orders)",
          "type": "integer",
          "format": "int64"
        },
        "trip": {
          "description": "trip delivering the order (automatically populated for parcel-carrier orders)",
          "type": "integer",
          "format": "int64"
        },
        "address": {
          "description": "parcel-carrier delivery location (unset for truck orders)",
          "$ref": "#/definitions/address"
        },
        "notes": {
          "description": "Additional information about the order, including special instructions for Azure's pickers",
          "type": "string"
        }
      },
      "required": [
        "customer",
        "status"
      ]
    },
    "changedOrder": {
      "description": "an updated order and a list of any side-effects from the update",
      "type": "object",
      "properties": {
        "order": {
          "description": "The updated order",
          "$ref": "#/definitions/order"
        },
        "changes": {
          "description": "An array of side-effects.  Will be set if there were side-effects and unset if there were none",
          "type": "array",
          "items": {
            "$ref": "#/defintition/orderChange"
          }
        }
      },
      "required": [
        "order"
      ]
    },
    "orderChange": {
      "description": "A side-effect from an order update",
      "type": "object",
      "properties": {
        "type": {
          "description": "A slug identifying the type of change",
          "type": "string",
          "enum": [
            "remove-order-line"
          ]
        },
        "reason": {
          "description": "A human-readable description of the change",
          "type": "string"
        },
        "order-line": {
          "description": "An inline copy of the affected line.  In the case of line removals, this entry will no longer exist in the API backend, although customers may attempt to create new order lines based on the inline information",
          "$ref": "#/definitions/orderLine"
        }
      },
      "required": [
        "change",
        "reason"
      ]
    },
    "orderCases": {
      "description": "Quantity of shipped boxes and bulk stock",
      "type": "object",
      "properties": {
        "dry": {
          "description": "Quantity of shipped boxes and bulk stock with the dry climate",
          "type": "integer",
          "format": "int32"
        },
        "chilled": {
          "description": "Quantity of shipped boxes and bulk stock with the chilled climate",
          "type": "integer",
          "format": "int32"
        },
        "frozen": {
          "description": "Quantity of shipped boxes and bulk stock with the frozen climate",
          "type": "integer",
          "format": "int32"
        },
        "greenhouse": {
          "description": "Quantity of shipped boxes and bulk stock with the greenhouse climate",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "orderLine": {
      "description": "a per-product entry in an order",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "order": {
          "description": "order that the order-line belongs to",
          "type": "integer",
          "format": "int64"
        },
        "packaged-product": {
          "description": "packaged product code that is being ordered",
          "type": "string"
        },
        "quantity-ordered": {
          "description": "number of product instances requested",
          "type": "integer",
          "format": "int32"
        },
        "quantity-shipped": {
          "description": "number of product instances delivered",
          "type": "integer",
          "format": "int32"
        },
        "weight": {
          "description": "weight of the shipped products in pounds (estimated until picking time)",
          "type": "number",
          "format": "float"
        },
        "volume": {
          "description": "volume of the shipped products in cubic feet (estimated until picking time)",
          "type": "number",
          "format": "float"
        },
        "price": {
          "description": "the total price for this line in dollars (estimated until picking time).  The per-unit price used to calculate this total is currently locked in when you place the order.",
          "type": "number",
          "format": "float"
        },
        "warnings": {
          "description": "An array of warnings about this product.",
          "type": "array",
          "items": {
            "description": "Warnings about products that a customer can associate with this order, but maybe should not (e.g. that is is likely to expire before reaching the customer)",
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "order",
        "name",
        "quantity-ordered",
        "weight",
        "volume"
      ]
    },
    "updateOrderLine": {
      "description": "a per-product entry in an order",
      "type": "object",
      "properties": {
        "order": {
          "description": "order that the order-line belongs to",
          "type": "integer",
          "format": "int64"
        },
        "packaged-product": {
          "description": "packaged product code that is being ordered",
          "type": "string"
        },
        "name": {
          "description": "most order lines are for packaged products, but Azure sometimes bills for less concrete items like catalog ads.  This field holds a brief description of the line, and should be used for invoices instead of following packaged-product (which may not be set).",
          "type": "string"
        },
        "quantity-ordered": {
          "description": "number of product instances requested",
          "type": "integer",
          "format": "int32"
        }
      },
      "required": [
        "order",
        "quantity-ordered"
      ]
    },
    "orderFee": {
      "description": "An additional charge associated with an order (estimated until picking time).",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "order": {
          "description": "Order that the fee belongs to",
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "Fee type slug",
          "$ref": "#/definitions/orderFeeType"
        },
        "amount": {
          "description": "Dollar value for the fee",
          "type": "number",
          "format": "float"
        },
        "notes": {
          "description": "Additional information about the reason or amount for the fee",
          "type": "string"
        }
      },
      "required": [
        "order",
        "type",
        "amount"
      ]
    },
    "orderFeeType": {
      "description": "A property for an order fee",
      "type": "string",
      "enum": [
        "shipping",
        "small-order"
      ]
    },
    "vendor": {
      "description": "a company that sells products to Azure",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "active": {
          "description": "whether or not this vendor is actively supplying purchases",
          "type": "boolean"
        },
        "url": {
          "description": "homepage for the vendor",
          "type": "string",
          "format": "url"
        },
        "indie": {
          "description": "whether or not this vendor is a privately held company",
          "type": "boolean"
        },
        "account": {
          "description": "vendor's identifier for Azure",
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "active"
      ]
    },
    "accountEntry": {
      "description": "an entry in a person's acount",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "person": {
          "description": "person associated with the account",
          "type": "integer",
          "format": "int64"
        },
        "amount": {
          "description": "dollar value for the entry (positive for credits like customer payments, negative for debits like order charges)",
          "type": "number",
          "format": "float"
        },
        "date": {
          "description": "when the entry was added",
          "type": "string",
          "format": "date"
        },
        "notes": {
          "description": "a line of Markdown identifying the entry (e.g. \"charge for order 123\" or \"payed with card ending in 0123\").",
          "type": "string"
        },
        "balance": {
          "description": "account balance after this account entry",
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "id",
        "person",
        "amount",
        "date"
      ]
    },
    "creditCard": {
      "description": "a credit card (one of our supported payment methods)",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "string identifying this payment method",
          "type": "string",
          "enum": [
            "credit-card"
          ]
        },
        "active": {
          "description": "whether or not this payment method is available for further activity",
          "type": "boolean"
        },
        "person": {
          "description": "person associated with this payment method",
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "billing name (which may differ from the associated person's name)",
          "type": "string"
        },
        "address": {
          "description": "billing address associated with this credit card",
          "$ref": "#/definitions/address"
        },
        "issuer": {
          "description": "provider network.  You can determine this from the leading digits of the card number, but we don't store those digits",
          "type": "string"
        },
        "last-four": {
          "description": "last four digits of the card number for identification",
          "type": "string"
        },
        "expiration": {
          "description": "expiration date.  We only use the month and year; the day will always be '01'.",
          "type": "string",
          "format": "date"
        }
      },
      "required": [
        "id",
        "type",
        "active",
        "person",
        "name",
        "address",
        "last-four",
        "expiration"
      ]
    },
    "newCreditCard": {
      "description": "Azure does not store much credit card information internally (we use an external card processor), but we do need all of the information for the initial upload so we can pass it along to the external processor.",
      "type": "object",
      "properties": {
        "type": {
          "description": "string identifying this payment method",
          "type": "string",
          "enum": [
            "credit-card"
          ]
        },
        "active": {
          "description": "whether or not this payment method is available for further activity.  Defaults to true",
          "type": "boolean"
        },
        "person": {
          "description": "person associated with this payment method",
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "billing name (which may differ from the associated person's name)",
          "type": "string"
        },
        "address": {
          "description": "billing address associated with this credit card",
          "type": "integer",
          "format": "int64"
        },
        "number": {
          "description": "card number",
          "type": "string"
        },
        "security-code": {
          "description": "security code (also known as the verification value)",
          "type": "string"
        },
        "expiration": {
          "description": "expiration date.  We only use the month and year and ignore the day (which you should set to '01').",
          "type": "string",
          "format": "date"
        }
      },
      "required": [
        "type",
        "person",
        "name",
        "address",
        "number",
        "security-code",
        "expiration"
      ]
    },
    "genericPaymentMethod": {
      "description": "one of our supported payment methods that does not have properties beyond the generic payment-method properties",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "string identifying this payment method.  cash-on-delivery means customers must pay for their order in cash to pick up the order.  hold-for-payment means customers must pay for the order before Azure will ship it.  net-N means the order must be paid for within N days.  payroll-deduction means the invoiced price will be deducted from the customer's (an Azure employee) next paycheck.",
          "type": "string",
          "enum": [
            "cash-on-delivery",
            "hold-for-payment",
            "net-10-days",
            "net-30-days",
            "payroll-deduction"
          ]
        },
        "active": {
          "description": "whether or not this payment method is available for further activity",
          "type": "boolean"
        },
        "person": {
          "description": "person associated with this payment method",
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "id",
        "type",
        "active",
        "person"
      ]
    },
    "paymentMethod": {
      "anyOf": [
        {
          "$ref": "#definitions/creditCard"
        },
        {
          "$ref": "#definitions/genericPaymentMethod"
        }
      ]
    },
    "newPaymentMethod": {
      "anyOf": [
        {
          "$ref": "#definitions/newCreditCard"
        }
      ]
    },
    "payment": {
      "description": "A payment instance where an amount will be (or has been) charged via a payment-method.",
      "type": "object",
      "properties": {
        "payment-method": {
          "description": "Payment-method ID to use (or which was used)",
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "The type of payment used",
          "type": "string"
        },
        "last-four": {
          "description": "The last four digits of the credit card used. Only included if the payment type is Credit Card",
          "type": "string"
        },
        "amount": {
          "description": "Amount to charge (or which was charged) in dollars",
          "type": "number",
          "format": "float"
        },
        "paid": {
          "description": "Has the payment been charged?",
          "type": "boolean"
        }
      },
      "required": [
        "payment-method"
      ]
    },
    "registrationRequest": {
      "description": "A request for registering a new person",
      "type": "object",
      "properties": {
        "person": {
          "description": "The registrant's personal information.  'name' is required.",
          "type": "object",
          "schema": {
            "$ref": "#/definitions/updatePerson"
          }
        },
        "catalog": {
          "description": "Set to true to receive the catalog after registration.",
          "type": "boolean"
        },
        "address": {
          "description": "The registrant's mailing address (required if they've set catalog or person.sale-magazine).",
          "type": "object",
          "schema": {
            "$ref": "#/definitions/address"
          }
        },
        "email": {
          "description": "The registrant's primary email address.  Will have a preference level of 100.",
          "type": "string",
          "format": "email"
        },
        "telephone": {
          "description": "The registrant's telephone numbers (currently only supports 'voice' and 'text' types)",
          "type": "array",
          "items": {
            "$ref": "#/definitions/telephone"
          }
        },
        "drop": {
          "description": "The registrant's chosen drop",
          "type": "integer",
          "format": "int64"
        },
        "context": {
          "description": "The context in which the registration request is being made (to select between available notification templates).  Defaults to \"registration\".",
          "format": "array",
          "items": {
            "type": "string",
            "enum": [
              "registration",
              "checkout",
              "catalog-request"
            ]
          }
        },
        "authentication-base-url": {
          "description": "Redirect URL for the authentication UI.  The authentication notification points customers at {authentication-base-url}{authentication-token} to authenticate a new session.",
          "type": "string",
          "format": "url"
        },
        "confirmation-base-url": {
          "description": "Redirect URL for the channel-confirmation UI.  The channel-confirmation notification points customers at {confirmation-base-url}{confirmation-token} to confirm the notification channel.",
          "type": "string",
          "format": "url"
        }
      },
      "required": [
        "person",
        "email",
        "authentication-base-url",
        "confirmation-base-url"
      ]
    },
    "registrationResponse": {
      "description": "The registration response",
      "type": "object",
      "properties": {
        "session": {
          "$ref": "#/definitions/session"
        },
        "auth-token": {
          "description": "Auth token.  Can be sent to login to authenticate a new session.",
          "type": "string"
        },
        "resend-token": {
          "description": "Resend token.  Can be sent to resendRegistrationEmail to trigger a new registration notification.",
          "type": "string"
        },
        "required": [
          "session",
          "resend-token"
        ]
      }
    },
    "resendRegistrationEmail": {
      "description": "A request for another registration email",
      "type": "object",
      "properties": {
        "base-url": {
          "description": "Redirect URL for the confirmation UI.  The confirmation email points customers at {base-url}{confirmation-token} to confirm their registration.",
          "type": "string",
          "format": "url"
        },
        "token": {
          "description": "The registrant's resend token.  If token is unset, the request must be authenticated with basic auth or a session cookie.",
          "type": "string"
        }
      },
      "required": [
        "base-url"
      ]
    },
    "token": {
      "description": "Authentication credentials",
      "type": "object",
      "properties": {
        "token": {
          "description": "Token for authentication.",
          "type": "string"
        }
      },
      "required": [
        "token"
      ]
    },
    "usernamePassword": {
      "description": "Authentication credentials",
      "type": "object",
      "properties": {
        "username": {
          "description": "Username for authentication.  Instead of your username, you could also use your primary email address or your person ID here",
          "type": "string"
        },
        "password": {
          "description": "Password for authentication",
          "type": "string"
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "passwordResetRequest": {
      "description": "A request for a password-reset token",
      "type": "object",
      "properties": {
        "base-url": {
          "description": "Redirect URL for the password reset UI.  The password reset email points customers at {base-url}{confirmation-token} to confirm their password reset.",
          "type": "string",
          "format": "url"
        },
        "email": {
          "description": "The email address for the person whose password will be reset.  Instead of the email address, you may also use your username or person ID here",
          "type": "string"
        }
      },
      "required": [
        "base-url",
        "email"
      ]
    },
    "passwordResetConfirmation": {
      "description": "A request to reset a password using a password-reset token",
      "type": "object",
      "properties": {
        "token": {
          "description": "The password-reset confirmation token",
          "type": "string"
        },
        "password": {
          "description": "The new password",
          "type": "string"
        }
      },
      "required": [
        "token",
        "password"
      ]
    },
    "notificationChannel": {
      "description": "channel technology for pushing user notifications",
      "type": "string",
      "enum": [
        "email",
        "text"
      ]
    },
    "telephone": {
      "description": "A telephone number",
      "type": "object",
      "properties": {
        "pref": {
          "description": "Mark a preferred-use telephone number (assumed false)",
          "type": "boolean"
        },
        "type": {
          "description": "An array of properties for this number",
          "type": "array",
          "items": {
            "$ref": "#/definitions/telephoneType"
          }
        },
        "number": {
          "description": "E.123 telephone number",
          "type": "string",
          "format": "telephone"
        }
      },
      "required": [
        "type",
        "number"
      ]
    },
    "telephoneType": {
      "description": "a property of a telephone number",
      "type": "string",
      "enum": [
        "text",
        "voice"
      ]
    },
    "person": {
      "description": "a person (customer, vendor, employee, ...)",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "email": {
          "description": "The person's preferred, error-less email address (set if the \"inline\" query parameter contains \"email\").",
          "type": "string",
          "format": "email"
        },
        "can-email": {
          "description": "Can Azure contact this person for reasons other than registration",
          "type": "boolean"
        },
        "sale-magazine": {
          "description": "Set to true to receive the sale magazine",
          "type": "boolean"
        },
        "company": {
          "description": "Employer name",
          "type": "string"
        },
        "allow-social-media": {
          "description": "Does this person want social media links to display",
          "type": "boolean"
        },
        "price-level": {
          "$ref": "#/definitions/priceLevel"
        },
        "notifications": {
          "$ref": "#/definitions/personNotifications"
        },
        "permissions": {
          "description": "API permissions for this person",
          "type": "array",
          "items": {
            "$ref": "#/definitions/permission"
          }
        },
        "internal-notes": {
          "description": "free-form Markdown notes for any internal information that doesn't fit into an existing field.  Only Azure employees can view or edit this information, although it may be passed into the registerPerson endpoint when registering new people.",
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "notifications"
      ]
    },
    "updatePerson": {
      "description": "a person (customer, vendor, employee, ...)",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "password": {
          "description": "Password for authentication",
          "type": "string"
        },
        "can-email": {
          "description": "Can Azure contact this person for reasons other than registration?  Defaults to true when creating a person",
          "type": "boolean"
        },
        "sale-magazine": {
          "description": "Subscribed to receive the sale magazine?  Defaults to false when creating a person",
          "type": "boolean"
        },
        "company": {
          "description": "Employer name",
          "type": "string"
        },
        "allow-social-media": {
          "description": "Does this person want social media links to display?  Defaults to true when creating a person",
          "type": "boolean"
        },
        "notifications": {
          "$ref": "#/definitions/personNotifications"
        }
      }
    },
    "updatePersonUserPassword": {
      "description": "a person (customer, vendor, employee, ...) with the logged in user's password",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "password": {
          "description": "Password for authentication",
          "type": "string"
        },
        "can-email": {
          "description": "Can Azure contact this person for reasons other than registration",
          "type": "boolean"
        },
        "sale-magazine": {
          "description": "Subscribed to receive the sale magazine",
          "type": "boolean"
        },
        "company": {
          "description": "Employer name",
          "type": "string"
        },
        "allow-social-media": {
          "description": "Does this person want social media links to display",
          "type": "boolean"
        },
        "user-password": {
          "description": "The authenticated person's password, required when changing password",
          "type": "string"
        },
        "notifications": {
          "$ref": "#/definitions/personNotifications"
        }
      }
    },
    "personNotifications": {
      "description": "configure if and how a user receives per-user notifications",
      "type": "object",
      "properties": {
        "checkout": {
          "description": "sent after checking out orders.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        },
        "delivery": {
          "description": "sent after order delivery, and after updates to delivery estimates.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        },
        "payment": {
          "description": "sent after Azure processes a payment.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        },
        "invoice": {
          "description": "sent when new invoices are generated",
          "format": "array",
          "items": {
            "type": "string",
            "enum": [
              "paper",
              "email"
            ]
          }
        }
      }
    },
    "address": {
      "description": "an address following the convention of http://microformats.org/wiki/h-adr and https://tools.ietf.org/html/rfc6350#section-6.3.1, with an additional \"name\" property",
      "type": "object",
      "properties": {
        "name": {
          "description": "contact name for this address (e.g. \"Mr. John Q. Public, Esq.\")",
          "type": "string"
        },
        "post-office-box": {
          "type": "string"
        },
        "extended-address": {
          "type": "string"
        },
        "street-address": {
          "type": "string"
        },
        "locality": {
          "type": "string"
        },
        "region": {
          "description": "required for the United States and Canada, optional for other countries",
          "type": "string"
        },
        "postal-code": {
          "type": "string"
        },
        "country": {
          "description": "ISO 3166-1 alpha-3 code for the country.  On push, you can set the alpha-2 code or case-insensitve name instead, or you can use an inline country object.",
          "type": "string"
        },
        "preference": {
          "description": "ordering precedence for the findAddresses.  Defaults to zero.",
          "type": "integer",
          "format": "int32"
        }
      },
      "required": [
        "locality",
        "country"
      ]
    },
    "country": {
      "description": "a country",
      "type": "object",
      "properties": {
        "name": {
          "description": "country name",
          "type": "string"
        },
        "iso": {
          "description": "The country's ISO 3166-1 alpha-2 code",
          "type": "string"
        },
        "iso3": {
          "description": "The country's ISO 3166-1 alpha-3 code",
          "type": "string"
        }
      },
      "required": [
        "name",
        "iso",
        "iso3"
      ]
    },
    "region": {
      "description": "a country region (US state or Canadian province)",
      "type": "object",
      "properties": {
        "name": {
          "description": "region name",
          "type": "string"
        },
        "abbreviation": {
          "type": "string"
        },
        "country-iso3": {
          "type": "string"
        }
      }
    },
    "location": {
      "description": "a named geographic coordinate with an enumerated label",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "geo": {
          "$ref": "#/definitions/geo"
        },
        "label": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "geo"
      ]
    },
    "geo": {
      "description": "a geographical coordinate",
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "float"
        },
        "longitude": {
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "latitude",
        "longitude"
      ]
    },
    "email": {
      "description": "An email address.",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "address": {
          "type": "string",
          "format": "email"
        },
        "person": {
          "description": "Person associated with this email.",
          "type": "integer",
          "format": "int64"
        },
        "error": {
          "description": "Reason for not using this address (e.g. \"unconfirmed\", \"email bounced on 2016-08-15\").",
          "type": "string"
        },
        "preference": {
          "description": "Ordering precedence for the findEmails.",
          "type": "integer",
          "format": "int32"
        }
      },
      "required": [
        "id",
        "address",
        "person"
      ]
    },
    "updateEmailUserPassword": {
      "description": "A request for adding or updating an email address with the logged in user's password",
      "type": "object",
      "properties": {
        "base-url": {
          "description": "Redirect URL for the confirmation UI.  The confirmation email points customers at {base-url}{confirmation-token} to confirm their registration.  Required if address is changing; optional if address is not changing.",
          "type": "string",
          "format": "url"
        },
        "address": {
          "type": "string",
          "format": "email"
        },
        "person": {
          "description": "Person associated with this email.",
          "type": "integer",
          "format": "int64"
        },
        "preference": {
          "description": "Ordering precedence for the findEmails.",
          "type": "integer",
          "format": "int32"
        },
        "user-password": {
          "description": "The authenticated person's password.",
          "type": "string"
        }
      },
      "required": [
        "address",
        "person",
        "user-password"
      ]
    },
    "updatedEmail": {
      "description": "An updated (but unconfirmed) email response.",
      "type": "object",
      "properties": {
        "token": {
          "description": "Resend token for resendEmailConfirmation (not the same as the confirmation token emailed to the user, which is for emailConfirmation).  Unset if a confirmation email was not set (more details on this in updateEmail).",
          "type": "string"
        },
        "email": {
          "$ref": "#/definitions/email"
        }
      },
      "required": [
        "email"
      ]
    },
    "favorite": {
      "description": "a customer favorite",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "quantity": {
          "type": "integer",
          "format": "int64"
        },
        "packaged-product": {
          "type": "string"
        },
        "customer": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "id",
        "quantity",
        "packaged-product",
        "customer"
      ]
    },
    "updateFavorite": {
      "description": "a customer favorite",
      "type": "object",
      "properties": {
        "quantity": {
          "type": "integer",
          "format": "int64"
        },
        "packaged-product": {
          "type": "string"
        },
        "customer": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "quantity",
        "packaged-product",
        "customer"
      ]
    },
    "faq": {
      "description": "frequently asked question",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "question": {
          "description": "a frequently asked question in plain text.",
          "type": "string"
        },
        "answer": {
          "description": "the answer to the associated question in plain text.",
          "type": "string"
        },
        "order": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "id",
        "question",
        "answer",
        "order"
      ]
    },
    "updateFaq": {
      "description": "frequently asked question",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "question": {
          "description": "a frequently asked question in plain text.",
          "type": "string"
        },
        "answer": {
          "description": "the answer to the associated question in plain text.",
          "type": "string"
        },
        "order": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "question",
        "answer",
        "order"
      ]
    },
    "session": {
      "description": "session cookie information",
      "type": "object",
      "properties": {
        "person": {
          "description": "person ID for the session owner (unset for anonymous sessions)",
          "type": "integer",
          "format": "int64"
        },
        "expires": {
          "description": "current expiration date-time for this session (http://tools.ietf.org/html/rfc6265#section-5.3, covering both Max-Age and Expires representations, unset if the session expires at browser-close)",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "notification": {
      "description": "a notification to display on the website",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "message": {
          "type": "string"
        },
        "active": {
          "type": "boolean"
        },
        "dismissed": {
          "type": "boolean",
          "description": "if annotate-person is specified in the request, this field will note if the notification has been dismissed"
        }
      },
      "required": [
        "id",
        "message"
      ]
    },
    "notificationDismissal": {
      "description": "a dismissal used to hide a read notification",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "notification": {
          "type": "integer",
          "format": "int64"
        },
        "person": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "notification",
        "person"
      ]
    },
    "productAudit": {
      "description": "an audited or auditable product and its packaging",
      "type": "object",
      "properties": {
        "id": {
          "description": "the product ID (not unique to the audit process)",
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "sentence-length product name.  Copied from `#definitions/product` for easier UI development",
          "type": "string"
        },
        "packaging": {
          "description": "all related audited and/or non-audited packaged versions of this product",
          "type": "array",
          "items": {
            "$ref": "#/definitions/packagedProductAudit"
          }
        }
      },
      "required": [
        "id",
        "name",
        "packaging"
      ]
    },
    "packagedProductAudit": {
      "description": "an audited or auditable packaged-product",
      "type": "object",
      "properties": {
        "id": {
          "description": "the packaged-product id (not unique to the audit process)",
          "type": "string"
        },
        "size": {
          "description": "the old size of the product (e.g. \"12 oz.\" or \"6x12 oz.\")",
          "type": "string"
        },
        "packs": {
          "description": "the new dimensions of package sizes (e.g. \"4\", \"4x32.5\", or \"2x4x32.5\")",
          "type": "string"
        },
        "unit": {
          "description": "the new unit of measurement.  You can use any string, but the backend will only be able to make automatic comparisons if you use SI prefixes (e.g. \"mm\" for millimeters) and stick to the following base units: pound, ounce, gram, gallon, liter, quart, pint, cup, fluid ounce, yard, and count",
          "type": "string"
        },
        "audited": {
          "description": "a datetime denoting if and when the packaged-product was last audited",
          "type": "date-time"
        }
      },
      "required": [
        "id",
        "size",
        "packs",
        "unit",
        "audited"
      ]
    },
    "updatePackagedProductAudit": {
      "description": "an update to an audited packaged-product",
      "type": "object",
      "properties": {
        "packs": {
          "description": "the new dimensions of package sizes (e.g. \"4\", \"4x32.5\", or \"2x4x32.5\")",
          "type": "string"
        },
        "unit": {
          "description": "the new unit of measurement.  Ideally one of \"\", or \"\", but you can use another unit if none of those fit.",
          "type": "string"
        },
        "size": {
          "description": "override the auto-generated size (based on packs and unit) with a custom name.  This can be useful for adding packaging information (e.g. \"32 floz glass\" to distinguish glass from plastic vinegar bottles).",
          "type": "string"
        },
        "clear-audited": {
          "description": "If true, clear the audited date-time for this packaged-product.  If false (the default), set the audited date-time to the current time.",
          "type": "boolean"
        }
      },
      "required": [
        "packs",
        "unit"
      ]
    },
    "printer": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "delivery": {
          "description": "the printer delivery type slug",
          "$ref": "#/definitions/printerDeliveryType"
        },
        "format": {
          "description": "the printer format type slug",
          "$ref": "#/definitions/printerFormatType"
        },
        "warehouse": {
          "description": "the warehouse's code",
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "delivery",
        "format",
        "warehouse"
      ]
    },
    "printerDeliveryType": {
      "description": "A property for printer delivery method",
      "type": "string",
      "enum": [
        "http",
        "cups",
        "bartender"
      ]
    },
    "printerFormatType": {
      "description": "A property for printer format method",
      "type": "string",
      "enum": [
        "pdf",
        "epl2",
        "bartender"
      ]
    },
    "warehouse": {
      "description": "a physical warehouse or facility",
      "type": "object",
      "properties": {
        "code": {
          "description": "slug for stable reference (e.g. \"moro\")",
          "type": "string"
        },
        "name": {
          "description": "human readable name (e.g. \"Moro\")",
          "type": "string"
        }
      },
      "required": [
        "code",
        "name"
      ]
    },
    "ip2location": {
      "description": "location information for an ip address",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/address"
        },
        "geo": {
          "$ref": "#/definitions/geo"
        }
      },
      "required": [
        "address",
        "geo"
      ]
    },
    "errorModel": {
      "required": [
        "code",
        "message"
      ],
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        }
      }
    }
  }
}
