{
  "swagger": "2.0",
  "info": {
    "version": "1.0.0",
    "title": "Azure Standard Public API",
    "description": "The public API behind Azure's website",
    "contact": {
      "name": "Azure Standard Customer Service",
      "email": "info@azurestandard.com",
      "url": "https://azurestandard.com/customer-service"
    },
    "license": {
      "name": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  },
  "security": [
    {
      "basic": []
    },
    {
      "sessionCookie": []
    }
  ],
  "securityDefinitions": {
    "basic": {
      "type": "basic",
      "description": "Basic authentication (http://tools.ietf.org/html/rfc2617#section-2)"
    },
    "sessionCookie": {
      "type": "apiKey",
      "in": "header",
      "name": "cookie",
      "description": "Session cookie (http://tools.ietf.org/html/rfc6265)"
    }
  },
  "host": "api.azurestandard.com",
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/drops": {
      "get": {
        "summary": "Returns all drops from the system that the user has access to",
        "operationId": "findDrops",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active drops",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/drop"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new drop",
        "operationId": "addDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "body",
            "description": "Drop to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newDrop"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "$ref": "#/definitions/drop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drop/{id}": {
      "get": {
        "summary": "Returns a drop based on a single ID, if the user has access to the drop",
        "operationId": "findDropById",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "$ref": "#/definitions/drop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing drop",
        "operationId": "updateDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "drop",
            "in": "body",
            "description": "Updated drop parameters (can optionally include 'id')",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateDrop"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop response",
            "schema": {
              "$ref": "#/definitions/drop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing drop",
        "operationId": "deleteDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drops/locations": {
      "get": {
        "summary": "Returns an array of locations for all active drops that the user has access to.",
        "description": "For example, you can use this to draw markers on map.",
        "operationId": "findDropLocations",
        "tags": [
          "drop"
        ],
        "responses": {
          "200": {
            "description": "drop locations response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/location"
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drop-memberships": {
      "get": {
        "summary": "Returns all drop memberships from the system that the user has access to",
        "operationId": "findDropMemberships",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/dropMembership"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new drop membership",
        "operationId": "addDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "drop-membership",
            "in": "body",
            "description": "drop membership to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newDropMembership"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "$ref": "#/definitions/dropMembership"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/drop-membership/{id}": {
      "get": {
        "summary": "Returns a drop membership based on a single membership ID, if the user has access.",
        "operationId": "findDropMembershipById",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "$ref": "#/definitions/dropMembership"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing drop membership if the user has the access.",
        "operationId": "updateDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "drop-membership",
            "in": "body",
            "description": "Updated drop membership parameters",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateDropMembership"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "drop membership response",
            "schema": {
              "$ref": "#/definitions/dropMembership"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing drop membership",
        "operationId": "deleteDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/routes": {
      "get": {
        "summary": "Returns all routes from the system that the user has access to",
        "operationId": "findRoutes",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/route"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new route",
        "operationId": "addRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "body",
            "description": "Route to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newRoute"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "$ref": "#/definitions/route"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/route/{name}": {
      "get": {
        "summary": "Returns a route based on a single ID, if the user has access to the route",
        "operationId": "findRouteById",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of route to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "$ref": "#/definitions/route"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing route",
        "operationId": "updateRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of route to update",
            "required": true,
            "type": "string"
          },
          {
            "name": "route",
            "in": "body",
            "description": "update route parameters",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateRoute"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "route response",
            "schema": {
              "$ref": "#/definitions/route"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Delete an existing route",
        "operationId": "deleteRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of route to delete",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/trips": {
      "get": {
        "summary": "Returns all trips from the system that the user has access to",
        "description": "Trips are ordered for decreasing cutoff time",
        "operationId": "findTrips",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "stop",
            "in": "query",
            "description": "stop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "cutoff-after",
            "in": "query",
            "description": "only return trips with cutoffs after or on this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "cutoff-before",
            "in": "query",
            "description": "only return trips with cutoffs before this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/trip"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Creates a trip for a route, if the user has permissions",
        "operationId": "addTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "trip",
            "in": "body",
            "description": "Trip to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateTrip"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "$ref": "#/definitions/trip"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/trip/{id}": {
      "get": {
        "summary": "Returns a trip based on a single ID, if the user has access to the trip",
        "operationId": "findTripById",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "$ref": "#/definitions/trip"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Updates a trip for a route, if the user has permissions",
        "operationId": "updateTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "trip",
            "in": "body",
            "description": "Trip to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateTrip"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "trip response",
            "schema": {
              "$ref": "#/definitions/trip"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "delete": {
        "summary": "Deletes a trip for a route, if the user has permissions",
        "operationId": "deleteTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/route-stops": {
      "get": {
        "summary": "Returns all route-stops from the system that the user has access to",
        "description": "Route-stops are ordered for increasing offset from the route's trip cutoff",
        "operationId": "findRouteStops",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "route-stop response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/routeStop"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/route-stop/{id}": {
      "get": {
        "summary": "Returns a route-stop based on a single ID, if the user has access to the route-stop",
        "operationId": "findRouteStopById",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of route-stop to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "route-stop response",
            "schema": {
              "$ref": "#/definitions/routeStop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/stops": {
      "get": {
        "summary": "Returns all stops from the system that the user has access to",
        "description": "Stops are ordered for decreasing target time",
        "operationId": "findStops",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "route names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs names to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "target-time-after",
            "in": "query",
            "description": "only return stops with a target time after or on this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "target-time-before",
            "in": "query",
            "description": "only return stops with a target time before this date",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "stop response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/stop"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/stop/{id}": {
      "get": {
        "summary": "Returns a stop based on a single ID, if the user has access to the stop",
        "operationId": "findStopById",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of stop to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "stop response",
            "schema": {
              "$ref": "#/definitions/stop"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/audit/products": {
      "get": {
        "summary": "Returns all products and their packaging from the system",
        "operationId": "findProductAudits",
        "tags": [
          "audit",
          "product"
        ],
        "parameters": [
          {
            "name": "audited",
            "in": "query",
            "description": "filter for products that have or haven't been audited.  When set, only products that contain (un)audited packaging are returned, and their packaging array only contains (un)audited packaging.",
            "required": false,
            "type": "string"
          },
          {
            "name": "search",
            "in": "query",
            "description": "search string for filtering products.  The logic behind this is left up to the implementation, but it should at least match words in the product name, and may optionally match the product description or other characteristics",
            "required": false,
            "type": "string"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged-product codes to filter by.",
            "required": false,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "product audit response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/productAudit"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/audit/product/{id}": {
      "get": {
        "summary": "Returns a product based on a single ID",
        "operationId": "findProductAuditById",
        "tags": [
          "audit",
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of product to fetch",
            "required": true,
            "type": "string"
          },
          {
            "name": "audited",
            "in": "query",
            "description": "When set, the packaging array only contains (un)audited packaging.",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "product audit response",
            "schema": {
              "$ref": "#/definitions/productAudit"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/audit/packaged-product/{id}": {
      "post": {
        "summary": "Audit an existing packaged-product",
        "operationId": "updatePackagedProductAudit",
        "tags": [
          "audit",
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "id of packaged product being audited",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "packaged-product",
            "in": "body",
            "description": "packaged product to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updatePackagedProductAudit"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "packaged-product audit response",
            "schema": {
              "$ref": "#/definitions/packagedProductAudit"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/products": {
      "get": {
        "summary": "Returns all products from the system that the user has access to",
        "operationId": "findProducts",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "search",
            "in": "query",
            "description": "search string for filtering products.  The logic behind this is left up to the implementation, but it should at least match words in the product name, and may optionally match the product description or other characteristics",
            "required": false,
            "type": "string"
          },
          {
            "name": "brand",
            "in": "query",
            "description": "brand IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "category",
            "in": "query",
            "description": "category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "primary-category",
            "in": "query",
            "description": "primary-category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ancestor-category",
            "in": "query",
            "description": "category IDs to filter by (for products associated with the categories or their descendants)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "tag",
            "in": "query",
            "description": "tags to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by (selects their favorite products)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "person ID for associating additional metadata with results (e.g. whether this person has favorited a given packaged-product).  If unset and you're authenticated, defaults to your authenticated ID",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "product response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/product"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/product/{id}": {
      "get": {
        "summary": "Returns a product based on a single ID, if the user has access to the product",
        "operationId": "findProductById",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of product to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "product response",
            "schema": {
              "$ref": "#/definitions/product"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-products": {
      "get": {
        "summary": "Returns all packaged products from the system that the user has access to",
        "operationId": "findPackagedProduct",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "brand",
            "in": "query",
            "description": "brand IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "category",
            "in": "query",
            "description": "category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "primary-category",
            "in": "query",
            "description": "primary-category IDs to filter by (for products directly associated with the categories)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ancestor-category",
            "in": "query",
            "description": "category IDs to filter by (for packaged products associated with the categories or their descendants)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "tag",
            "in": "query",
            "description": "tags to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by (selects their favorite packaged products)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "person ID for associating additional metadata with results (e.g. whether this person has favorited a given packaged-product).  If unset and you're authenticated, defaults to your authenticated ID",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/packagedProduct"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product/{code}": {
      "get": {
        "summary": "Returns a packaged product based on a single ID, if the user has access to the packaged product",
        "operationId": "findPackagedProductById",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "code of the packaged product to fetch",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "product response",
            "schema": {
              "$ref": "#/definitions/packagedProduct"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product-tags": {
      "get": {
        "summary": "Returns all packaged product tags from the system that the user has access to",
        "operationId": "findPackagedProductTag",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "internal",
            "in": "query",
            "description": "if true, only return internal tags (that the user has access to).  If false, only return public tags (regardless of the user's access to internal tags).  If unset, don't filter based on the tag visibility",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "category",
            "in": "query",
            "description": "categories to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product tag response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/packagedProductTag"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product-tag-associations": {
      "get": {
        "summary": "Return packaged product tag filter preferences for a person",
        "operationId": "findPackagedProductTagAssociations",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person ID to filter by",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product tag association response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/packagedProductTagAssociation"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Add a tag to a person's packaged product tag filter preferences",
        "operationId": "addPackagedProductTagAssociation",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "packaged-product-tag-assocation",
            "in": "body",
            "description": "Packaged-product tag association to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/packagedProductTagAssociation"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "packaged product tag association response",
            "schema": {
              "$ref": "#/definitions/packagedProductTagAssociation"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/packaged-product-tag-association/{id}": {
      "delete": {
        "summary": "Delete a packaged product tag association from a person's filter preferences",
        "operationId": "deletePackagedProductTagAssociation",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "packaged product tag association ID to delete",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/categories": {
      "get": {
        "summary": "Returns all categories from the system, ordered by decreasing 'featured' values",
        "operationId": "findCategories",
        "tags": [
          "category"
        ],
        "security": [],
        "parameters": [
          {
            "name": "parent",
            "in": "query",
            "description": "category IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/category"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new category",
        "operationId": "createCategory",
        "tags": [
          "category"
        ],
        "parameters": [
          {
            "name": "category",
            "in": "body",
            "description": "Category to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/category"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "$ref": "#/definitions/category"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/category/{id}": {
      "get": {
        "summary": "Returns a category based on a single ID",
        "operationId": "findCategoryById",
        "tags": [
          "category"
        ],
        "security": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of category to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "$ref": "#/definitions/category"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update a category.",
        "operationId": "updateCategory",
        "tags": [
          "category"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of category to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "category",
            "in": "body",
            "description": "Category to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/category"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "category response",
            "schema": {
              "$ref": "#/definitions/category"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/orders": {
      "get": {
        "summary": "Returns all orders from the system that the user has access to",
        "operationId": "findOrders",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "trip",
            "in": "query",
            "description": "trip IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "status",
            "in": "query",
            "description": "order-status string to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "cart",
                "placed",
                "shipped",
                "lost"
              ]
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "order response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/order"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order/{id}": {
      "get": {
        "summary": "Returns a order based on a single ID",
        "operationId": "findOrderById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "accept",
            "in": "query",
            "description": "override the HTTP Accept header to chose the response type.  Empty and unrecognized values will result in application/json.",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json",
          "application/pdf",
          "text/csv"
        ],
        "responses": {
          "200": {
            "description": "order response",
            "schema": {
              "$ref": "#/definitions/order"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order-lines": {
      "get": {
        "summary": "Returns all order-lines from the system that the user has access to",
        "operationId": "findOrderLines",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "order",
            "in": "query",
            "description": "order IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "product",
            "in": "query",
            "description": "product IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "packaged product codes to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "order-line response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/orderLine"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/order-line/{id}": {
      "get": {
        "summary": "Returns a order-line based on a single ID",
        "operationId": "findOrderLineById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order-line to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "order-line response",
            "schema": {
              "$ref": "#/definitions/orderLine"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/account-entries": {
      "get": {
        "summary": "Returns all credits and debits from the system that the user has access to",
        "operationId": "findAccountEntries",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "date-after",
            "in": "query",
            "description": "only return entries with dates after this date (inclusive)",
            "required": false,
            "type": "string",
            "format": "date"
          },
          {
            "name": "date-before",
            "in": "query",
            "description": "only return entries with dates before this date (exclusive)",
            "required": false,
            "type": "string",
            "format": "date"
          },
          {
            "name": "balance",
            "in": "query",
            "description": "add the balance field to returned entries",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "account entry response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/accountEntry"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/account-entry/{id}": {
      "get": {
        "summary": "Returns a credit or debit based on a single ID",
        "operationId": "findAccountEntryById",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of account entry to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "account entry response",
            "schema": {
              "$ref": "#/definitions/accountEntry"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/payments": {
      "post": {
        "summary": "Create a new payment (settled immediately)",
        "operationId": "addPayment",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "payment",
            "in": "body",
            "description": "Payment to create.  Amount and payment-method are both required.",
            "required": true,
            "schema": {
              "$ref": "#definitions/payment"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "account entry response",
            "schema": {
              "$ref": "#/definitions/accountEntry"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/payment-methods": {
      "get": {
        "summary": "Returns all payment methods from the system that the user has access to",
        "description": "Methods associated with a person are ordered by decreasing preference.  The ordering between methods associated with different people is undefined.",
        "operationId": "findPayments",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "payment method response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/paymentMethod"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new payment method",
        "operationId": "addPaymentMethod",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "payment-method",
            "in": "body",
            "description": "Payment method to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/newPaymentMethod"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "payment method response",
            "schema": {
              "$ref": "#/definitions/paymentMethod"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/payment-method/{id}": {
      "get": {
        "summary": "Returns a payment method based on a single ID",
        "operationId": "findPaymentMethodById",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of payment method to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "Payment method response",
            "schema": {
              "$ref": "#/definitions/paymentMethod"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/addresses": {
      "get": {
        "summary": "Returns all addresses from the system that the user has access to",
        "description": "Addresses associated with a person are ordered by decreasing preference.  The ordering between addresses associated with different people or (for the same person) with the same preference value is undefined.",
        "operationId": "findAddresses",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "address response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/address"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/address/{id}": {
      "get": {
        "summary": "Returns a address based on a single ID",
        "operationId": "findAddressById",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of address to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "address response",
            "schema": {
              "$ref": "#/definitions/address"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/people": {
      "get": {
        "summary": "Returns all people from the system that the user has access to",
        "operationId": "findPeople",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "drop IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/person"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/person/{id}": {
      "get": {
        "summary": "Returns a person based on a single ID, if the user has access to the person",
        "operationId": "findPersonById",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of person to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing person",
        "operationId": "updatePerson",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of person to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "person",
            "in": "body",
            "description": "Person to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updatePersonUserPassword"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/person": {
      "get": {
        "summary": "Returns the authenticated person (yourself)",
        "operationId": "findPersonByAuth",
        "tags": [
          "person"
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Update the authenticated person (yourself)",
        "operationId": "updatePersonByAuth",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "person",
            "in": "body",
            "description": "Person to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updatePersonUserPassword"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/session": {
      "get": {
        "summary": "Returns information about the current cookie-based session",
        "operationId": "findSessionByAuth",
        "tags": [
          "session"
        ],
        "security": [
          {
            "sessionCookie": []
          }
        ],
        "responses": {
          "200": {
            "description": "session response",
            "schema": {
              "$ref": "#/definitions/session"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/login": {
      "get": {
        "summary": "Authenticate and receive a session cookie",
        "operationId": "login",
        "tags": [
          "session"
        ],
        "parameters": [
          {
            "name": "login",
            "in": "body",
            "required": true,
            "type": "object",
            "schema": {
              "type": "object",
              "properties": {
                "username": {
                  "description": "Username for authentication.  Instead of your username, you could also use one of your associated email addresses or your person ID here",
                  "type": "string"
                },
                "password": {
                  "description": "Password for authentication",
                  "required": true,
                  "type": "string"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "session response",
            "schema": {
              "$ref": "#/definitions/session"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/logout": {
      "get": {
        "summary": "Clears the current cookie-based session",
        "operationId": "logout",
        "tags": [
          "session"
        ],
        "security": [
          {
            "sessionCookie": []
          }
        ],
        "responses": {
          "200": {
            "description": "session response",
            "schema": {
              "$ref": "#/definitions/session"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/registration/register": {
      "post": {
        "summary": "Register a new person",
        "description": "The API implementation will by sending the registrant a confirmation email.  That email will contain a confirmation URL with a registration token.  Following that URL will (possibly indirectly) send the token to this API's confirmation endpoint which completes the registration.  Since customers are unlikely to enjoy hitting the JSON confirmation endpoint directly, we recommend clients set base-url to something like `http://example.com/activation?token=` and have that page send a request to this API's confirmation endpoint and display the result returned by the API.  On success, this endpoint will also return a resend token (not the same as the confirmation token emailed to the registrant), which can be used by the client to trigger confirmation email resends.",
        "operationsId": "registerPerson",
        "tags": [
          "registration"
        ],
        "parameters": [
          {
            "name": "registration",
            "in": "body",
            "required": true,
            "type": "object",
            "schema": {
              "$ref": "#/definitions/registration"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "resend token (registration successfully initiated and confirmation email sent)",
            "type": "string"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/registration/confirm": {
      "get": {
        "summary": "Complete an in-progress registration",
        "operationId": "confirmRegistrationGet",
        "tags": [
          "registration"
        ],
        "parameters": [
          {
            "name": "token",
            "in": "query",
            "description": "The registrant's confirmation token",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Complete an in-progress registration",
        "operationId": "confirmRegistration",
        "tags": [
          "registration"
        ],
        "parameters": [
          {
            "name": "token",
            "in": "body",
            "description": "The registrant's confirmation token",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/registration/resend": {
      "post": {
        "summary": "Resend the confirmation email to the user",
        "operationId": "resendRegistrationEmail",
        "tags": [
          "registration"
        ],
        "parameters": [
          {
            "name": "resend",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/resendRegistrationEmail"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Confirmation email resent",
            "schema": {}
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/password/reset": {
      "post": {
        "summary": "Initiate a password reset, to be completed by a call to /password/confirm",
        "operationId": "resetPasswordRequest",
        "tags": [
          "password"
        ],
        "parameters": [
          {
            "name": "reset",
            "in": "body",
            "required": true,
            "type": "object",
            "schema": {
              "$ref": "#/definitions/passwordResetRequest"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Password-reset email sent (if the registration email corresponded to an existing person.  Otherwise, you'll still get a 204 to avoid leaking information about member email addresses)"
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/password/confirm": {
      "get": {
        "summary": "Complete an in-progress password reset",
        "operationId": "passwordResetGet",
        "tags": [
          "password"
        ],
        "parameters": [
          {
            "name": "token",
            "in": "query",
            "description": "The password-reset confirmation token",
            "required": true,
            "type": "string"
          },
          {
            "name": "password",
            "in": "query",
            "description": "The new password",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Complete an in-progress password reset",
        "operationId": "passwordResetConfirmation",
        "tags": [
          "password"
        ],
        "parameters": [
          {
            "name": "reset",
            "in": "body",
            "description": "The registrant's confirmation token",
            "required": true,
            "type": "object",
            "schema": {
              "$ref": "#/definitions/passwordResetConfirmation"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "person response",
            "schema": {
              "$ref": "#/definitions/person"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/notifications": {
      "get": {
        "summary": "Returns all notifications from the system that the user has access to",
        "operationId": "findNotifications",
        "tags": [
          "notification"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "only return (in)active notifications",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "add a boolean dismissed field to the results with whether or not the annotate-person has dismissed this notification, required with dismissed",
            "required": false,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "dismissed",
            "in": "query",
            "description": "only return notifications that are (not) dismissed by the annotate-person",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "notification response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/notification"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/notification-dismissals": {
      "post": {
        "summary": "Create a notification dismissal (a user may only dismiss notifications for himself)",
        "operationId": "addNotificationDismissal",
        "tags": [
          "notification"
        ],
        "parameters": [
          {
            "name": "notification-dismissal",
            "in": "body",
            "description": "Notification dismissal to add",
            "required": true,
            "schema": {
              "$ref": "#/definitions/notificationDismissal"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "notification dismissal response",
            "schema": {
              "$ref": "#/definitions/notificationDismissal"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      }
    },
    "/favorites": {
      "get": {
        "summary": "Returns a list of all customer's packaged product favorites",
        "operationId": "findFavorites",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "person IDs to filter by",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "active",
            "in": "query",
            "description": "only return favorites associated with (in)active packaged products.  For example, we sometimes discontinue products and then pick them back up later.  In this context, \"active\" means \"for sale to at least some customers\".",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "inline",
            "in": "query",
            "description": "for convenience, include a full representation of the inlined property. Currently supports \"packaged-product\" and \"packaged-product.product\".",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "array of favorites response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/favorite"
              }
            },
            "headers": {
              "Count": {
                "description": "total number of matching results (how many you'd get if you could set an infinite `limit`)",
                "type": "integer",
                "format": "int32",
                "minimum": 0
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Creates and returns a customer favorite",
        "operationId": "addFavorite",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "favorite",
            "in": "body",
            "description": "favorite to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFavorite"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "favorite response",
            "schema": {
              "$ref": "#/definitions/favorite"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/favorite/{id}": {
      "get": {
        "summary": "Returns a single customer favorite",
        "operationId": "findFavoriteById",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of favorite to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "favorite response",
            "schema": {
              "$ref": "#/definitions/favorite"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Updates and returns a customer favorite",
        "operationId": "updateFavorite",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of favorite to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "favorite",
            "in": "body",
            "description": "Favorite to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFavorite"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "favorite response",
            "schema": {
              "$ref": "#/definitions/favorite"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      },
      "delete": {
        "summary": "Deletes a customer favorite",
        "operationId": "deleteFavorite",
        "tags": [
          "favorite"
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/faqs": {
      "get": {
        "summary": "Returns a list of frequently asked questions and answers",
        "operationId": "getFaqs",
        "tags": [
          "faq"
        ],
        "perameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "maximum number of results to return",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "start",
            "in": "query",
            "description": "offset to the first result to return.  Use negative numbers to offset from the end of the result list.",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "responses": {
          "200": {
            "description": "array of faq response",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/faq"
              }
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "post": {
        "summary": "Creates and returns a faq",
        "operationId": "addFaq",
        "tags": [
          "faq"
        ],
        "parameters": [
          {
            "name": "faq",
            "in": "body",
            "description": "faq to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFaq"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "faq response",
            "schema": {
              "$ref": "#/definitions/faq"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    },
    "/faq/{id}": {
      "get": {
        "summary": "Returns a single faq",
        "operationId": "getFaqById",
        "tags": [
          "faq"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of faq to fetch",
            "required": true,
            "type": "integer",
            "format": "int64"
          }
        ],
        "responses": {
          "200": {
            "description": "faq response",
            "schema": {
              "$ref": "#/definitions/faq"
            }
          },
          "default": {
            "description": "unexpected error",
            "schema": {
              "$ref": "#/definitions/errorModel"
            }
          }
        }
      },
      "put": {
        "summary": "Updates and returns a faq",
        "operationId": "updateFaq",
        "tags": [
          "faq"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of faq to update",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "faq",
            "in": "body",
            "description": "Faq to update",
            "required": true,
            "schema": {
              "$ref": "#/definitions/updateFaq"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "faq response",
            "schema": {
              "$ref": "#/definitions/faq"
            }
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      },
      "delete": {
        "summary": "Deletes a faq",
        "operationId": "deleteFaq",
        "tags": [
          "faq"
        ],
        "responses": {
          "204": {
            "description": "delete successful"
          }
        },
        "default": {
          "description": "unexpected error",
          "schema": {
            "$ref": "#/definitions/errorModel"
          }
        }
      }
    }
  },
  "definitions": {
    "drop": {
      "description": "an order-delivery location",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "coordinators": {
          "description": "coordinators for this drop.  The first entry is the primary contact",
          "type": "array",
          "items": {
            "description": "person ID for this coordinator",
            "type": "integer",
            "format": "int32"
          }
        },
        "address": {
          "$ref": "#/definitions/address"
        },
        "geo": {
          "$ref": "#/definitions/geo"
        },
        "active": {
          "description": "whether or not this drop is actively ordering",
          "type": "boolean"
        },
        "accounts-payable-contact": {
          "description": "name of the drop employee Azure's accounts-payable should contact, if different from the primary contact",
          "type": "string"
        },
        "after-hours-phone": {
          "description": "E.123 telephone number Azure should call if we need to contact the drop after business hours",
          "type": "string"
        },
        "business-hours": {
          "description": "regular business hours for the drop (e.g. \"8:30-6 Mon-Fri, 9-5 Sat, closed Sun\")",
          "type": "string"
        },
        "business-type": {
          "description": "what type of business do you run?",
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "clinics-practitioner",
              "manufacturing-business",
              "online-store",
              "restaurant",
              "retail-store",
              "seasonal",
              "wholesale-distributor"
            ]
          }
        },
        "buyer": {
          "description": "name of the drop employee who usually places orders for this drop, if different from the primary contact",
          "type": "string"
        },
        "pickup-contact": {
          "description": "do customers need to contact you to pick up their orders?  Retail preference.  Only available when how-members-receive is \"can-hold-sometimes\" or \"can-hold\"",
          "type": "string",
          "enum": [
            "yes",
            "no",
            "first-time-only"
          ]
        },
        "contact-person": {
          "type": "string"
        },
        "contact-type": {
          "description": "how can customers contact you?",
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "phone",
              "email",
              "other"
            ]
          }
        },
        "contact-type-other-notes": {
          "description": "description of the alternative contact method.  Available when contact-type includes \"other\"",
          "type": "string"
        },
        "contact-type-phone": {
          "description": "E.123 telephone number customers should call to contact this drop.  Available when contact-type includes \"phone\"",
          "type": "string"
        },
        "directions": {
          "description": "driving directions for a truck approaching this drop (e.g. avoiding low bridges, tight turns, etc. on more obvious routes)",
          "type": "string"
        },
        "driver-callable-phone": {
          "description": "E.123 telephone number for a driver approaching this drop",
          "type": "string"
        },
        "exclusivity": {
          "type": "string",
          "enum": [
            "open",
            "semi-open",
            "closed"
          ]
        },
        "food-stamps": {
          "description": "does your drop accept food stamps?  Business preference.",
          "type": "string",
          "enum": [
            "yes",
            "no",
            "limited"
          ]
        },
        "food-stamps-limited-notes": {
          "description": "description of limited food-stamp acceptance.  Business preference.  Only available when food-stamps is \"limited\"",
          "type": "string"
        },
        "hold-time": {
          "description": "how long will you hold a customer's order?  For example, \"24 hours\", \"three days for dry, frozen by arrangement\", etc.  Retail preference.  Only available when how-members-receive is \"can-hold-sometimes\" or \"can-hold\"",
          "type": "string"
        },
        "how-members-receive": {
          "description": "how do your members receive their items?  Retail preference",
          "type": "string",
          "enum": [
            "must-show",
            "can-hold-sometimes",
            "can-hold"
          ]
        },
        "invoice-always": {
          "description": "always print paper invoices, regardless of the customer's invoice-delivery preference",
          "type": "boolean"
        },
        "okay-to-text-phone": {
          "description": "can the driver send text messages to the driver-callable phone?",
          "type": "boolean"
        },
        "parking": {
          "description": "parking location ownership for this drop",
          "type": "string",
          "enum": [
            "home",
            "business",
            "non-profit",
            "public",
            "other-building"
          ]
        },
        "special-orders": {
          "description": "do you take special orders for Azure products from customers?  Wholesale preference",
          "type": "boolean"
        },
        "storage": {
          "description": "storage facilities available at this drop",
          "type": "array",
          "items": {
            "description": "facility name",
            "type": "string",
            "enum": [
              "dry",
              "refregerator",
              "freezer"
            ]
          }
        },
        "fees": {
          "$fees": "#definitions/dropFees"
        },
        "order-minimum": {
          "description": "the minimum total order value (in dollars) required to ship a particular trip to this drop.  For example, if the minimum is $400 and there are three $100 orders placed for a stop, that stop will be under-minimum, and the orders will not be shipped.  If, on the other hand, there were four $100 orders placed for a stop, that stop would be (just) over-minimum, and the orders would be shipped.",
          "type": "number",
          "format": "float"
        },
        "members": {
          "description": "number of customers on this drop",
          "type": "integer",
          "format": "int32"
        },
        "order-frequency": {
          "description": "order counts for this drop over the past year",
          "type": "object",
          "properties": {
            "orders": {
              "description": "count of orders for this route-trip-drop",
              "type": "integer",
              "format": "int32"
            },
            "cutoff": {
              "description": "cutoff date for this route-trip",
              "type": "string",
              "format": "date"
            }
          }
        },
        "notes": {
          "description": "free-form Markdown notes for any drop information that doesn't fit into an existing field",
          "type": "string"
        },
        "sells-finished-goods-to-azure": {
          "description": "do you also sell your finished good to Azure?  Only available if business-type includes \"manufacturing-business\"",
          "type": "boolean"
        },
        "uses-azure-to-drop-ship": {
          "description": "Do you drop ship Azure orders (have Azure ship directly to your customers)?  Only available if business-type includes \"online-store\"",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "name",
        "geo",
        "active",
        "exclusivity",
        "members"
      ]
    },
    "newDrop": {
      "$ref": "drop"
    },
    "updateDrop": {
      "description": "an order-delivery location",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "address": {
          "$ref": "#/definitions/address"
        },
        "geo": {
          "description": "recalculated from address if not included",
          "$ref": "#/definitions/geo"
        },
        "active": {
          "description": "whether or not this drop is actively ordering",
          "type": "boolean"
        },
        "parking": {
          "description": "parking location ownership for this drop",
          "type": "string",
          "enum": [
            "home",
            "business",
            "non-profit",
            "public"
          ]
        },
        "storage": {
          "description": "storage facilities available at this drop",
          "type": "array",
          "items": {
            "description": "facility name",
            "type": "string",
            "enum": [
              "dry",
              "refregerator",
              "freezer"
            ]
          }
        },
        "fees": {
          "$fees": "#definitions/dropFees"
        },
        "notes": {
          "description": "free-form Markdown notes for any drop information that doesn't fit into an existing field",
          "type": "string"
        }
      },
      "required": [
        "name",
        "active"
      ]
    },
    "dropFees": {
      "description": "additional costs for members receiving at a drop",
      "type": "object",
      "properties": {
        "medium": {
          "description": "payment medium (nothing, volunteer time, or a monetary payment)",
          "type": "string",
          "enum": [
            "volunteer",
            "payment"
          ]
        },
        "condition": {
          "description": "fee trigger (never, only when orders are held, or for every order)",
          "type": "string",
          "enum": [
            "held",
            "order"
          ]
        },
        "notes": {
          "description": "fee amount and structure",
          "type": "string"
        }
      }
    },
    "dropMembership": {
      "description": "a drop membership",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "customer": {
          "description": "customer that has the drop membership",
          "type": "integer",
          "format": "int64"
        },
        "drop": {
          "description": "the drop this membership is for",
          "type": "integer",
          "format": "int64"
        },
        "notifications": {
          "$ref": "#/definitions/dropMembershipNotifications"
        }
      },
      "required": [
        "id",
        "name",
        "notifications",
        "customer",
        "drop"
      ]
    },
    "updateDropMembership": {
      "description": "a drop membership to update",
      "type": "object",
      "properties": {
        "drop": {
          "description": "the drop this membership is for",
          "type": "integer",
          "format": "int64"
        },
        "notifications": {
          "$ref": "#/definitions/dropMembershipNotifications"
        },
        "customer": {
          "description": "customer that has the drop membership",
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "customer",
        "drop"
      ]
    },
    "newDropMembership": {
      "$ref": "updateDropMembership"
    },
    "dropMembershipNotifications": {
      "description": "configure if and how a user receives per-drop notifications",
      "type": "object",
      "properties": {
        "cutoff": {
          "description": "receive notifications from Azure before cutoffs for this drop.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        }
      }
    },
    "route": {
      "description": "an order-delivery truck route",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "cutoff-frequency": {
          "description": "number of days between cutoffs",
          "type": "integer",
          "format": "int32"
        },
        "delivery-offset": {
          "description": "number of days after cutoff before the first stop",
          "type": "integer",
          "format": "int32"
        },
        "internal": {
          "description": "Is the route for internal use? This controls whether customers can access the route via the API (they can't if internal is true).",
          "type": "boolean"
        },
        "backhaul-cost-per-pound": {
          "description": "route backhaul cost per pound",
          "type": "number",
          "format": "float"
        },
        "backhaul-cost-per-pickup": {
          "description": "route backhaul cost per pickup",
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "name",
        "cutoff-frequency",
        "delivery-offset",
        "internal"
      ]
    },
    "updateRoute": {
      "description": "an order-delivery truck route's updated values",
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "cutoff-frequency": {
          "description": "number of days between cutoffs",
          "type": "integer",
          "format": "int32"
        },
        "delivery-offset": {
          "description": "number of days after cutoff before the first stop",
          "type": "integer",
          "format": "int32"
        },
        "internal": {
          "description": "Is the route for internal use? This controls whether customers can access the route via the API (they can't if internal is true).",
          "type": "boolean"
        },
        "backhaul-cost-per-pound": {
          "description": "route backhaul cost per pound",
          "type": "number",
          "format": "float"
        },
        "backhaul-cost-per-pickup": {
          "description": "route backhaul cost per pickup",
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "cutoff-frequency",
        "delivery-offset",
        "internal"
      ]
    },
    "newRoute": {
      "$ref": "route"
    },
    "trip": {
      "description": "a truck delivering orders along a route",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "route": {
          "description": "name of the followed route",
          "type": "string"
        },
        "cutoff": {
          "description": "cutoff for placing orders on this trip",
          "type": "string",
          "format": "date-time"
        },
        "pick-date": {
          "description": "date that orders for this trip should be picked",
          "type": "string",
          "format": "date-time"
        },
        "shipped": {
          "description": "approximately when the truck left the warehouse.  This will always be set after the truck has left, and will be unset until then.",
          "type": "string",
          "format": "date-time"
        },
        "delivery-start": {
          "description": "estimated stop-time for the first stop",
          "type": "string",
          "format": "date-time"
        },
        "delivery-end": {
          "description": "estimated stop-time for the last stop",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-start": {
          "description": "estimated date for the first backhaul",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-end": {
          "description": "estimated date for the last backhaul",
          "type": "string",
          "format": "date-time"
        },
        "warehouse-arrival": {
          "description": "estimated date for warehouse arrival",
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "route",
        "cutoff",
        "delivery-start"
      ]
    },
    "updateTrip": {
      "description": "a truck delivering orders along a route to be updated",
      "type": "object",
      "properties": {
        "route": {
          "description": "name of the followed route",
          "type": "string"
        },
        "cutoff": {
          "description": "cutoff for placing orders on this trip",
          "type": "string",
          "format": "date-time"
        },
        "pick-date": {
          "description": "date that orders for this trip should be picked",
          "type": "string",
          "format": "date-time"
        },
        "delivery-start": {
          "description": "estimated stop-time for the first stop",
          "type": "string",
          "format": "date-time"
        },
        "delivery-end": {
          "description": "estimated stop-time for the last stop",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-start": {
          "description": "estimated date for the first backhaul",
          "type": "string",
          "format": "date-time"
        },
        "backhaul-end": {
          "description": "estimated date for the last backhaul",
          "type": "string",
          "format": "date-time"
        },
        "warehouse-arrival": {
          "description": "estimated date for warehouse arrival",
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "route",
        "cutoff",
        "delivery-start"
      ]
    },
    "routeStop": {
      "description": "a template used to create stops when a trip is created",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "route": {
          "description": "route name for the route-stop",
          "type": "string"
        },
        "drop": {
          "description": "drop ID for the route-stop",
          "type": "integer",
          "format": "int64"
        },
        "delivery-offset": {
          "description": "offset from midnight on the morning of the trips's delivery start until the usual delivery time for this drop",
          "type": "string",
          "format": "duration"
        }
      },
      "required": [
        "id",
        "route",
        "drop",
        "target-time",
        "estimated-time"
      ]
    },
    "stop": {
      "description": "a trip stop or waypoint.  Stops are created for all route-stops when a trip is created for that route.  At verification time, stops that will not be visited (e.g. because they missed their order-minimum) are deleted",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "trip": {
          "description": "trip ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "drop": {
          "description": "drop ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "pickup": {
          "description": "pickup ID for the stop",
          "type": "integer",
          "format": "int64"
        },
        "target-time": {
          "description": "planned stop time (fixed before the trip starts)",
          "type": "string",
          "format": "date-time"
        },
        "estimated-time": {
          "description": "estimated stop time (updated after the trip starts until the stop is reached)",
          "type": "string",
          "format": "date-time"
        },
        "time": {
          "description": "actual stop time (set after the stop is reached)",
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "trip",
        "target-time",
        "estimated-time"
      ]
    },
    "packagedProduct": {
      "description": "a particular packaged form of a product",
      "type": "object",
      "properties": {
        "code": {
          "type": "string"
        },
        "size": {
          "description": "size of the product (e.g. 12 oz., or 6x12 oz.)",
          "type": "string"
        },
        "weight": {
          "minimum": {
            "description": "minimum weight of this packaged product in pounds",
            "type": "number",
            "format": "float"
          },
          "maximum": {
            "description": "maximum weight of this packaged product in pounds",
            "type": "number",
            "format": "float"
          },
          "average": {
            "description": "an estimate of the average weight of this packaged product in pounds",
            "type": "number",
            "format": "float"
          }
        },
        "volume": {
          "description": "volume of this packaged product in cubic feet",
          "type": "number",
          "format": "float"
        },
        "price": {
          "#ref": "#/definitions/price"
        },
        "stock": {
          "description": "amount of stock available for purchase",
          "type": "integer",
          "format": "int32"
        },
        "favorite": {
          "description": "if the annotate-person you associated with the request has favorited this packaged product",
          "type": "boolean"
        },
        "favorites": {
          "description": "number of people who've marked this packaged product as a favorite",
          "type": "integer",
          "format": "int32"
        },
        "images": {
          "type": "array",
          "items": {
            "description": "URL for a picture of this packaged product",
            "type": "string"
          }
        },
        "tags": {
          "description": "Mark types for this packaged product",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "bargain-bin-notes": {
          "description": "Bargain-bin notes for this packaged product",
          "type": "string"
        },
        "product": {
          "description": "the name and brand of the product that this packaged-product is associated with",
          "schema": {
            "$ref": "#/definitions/packagedProductProduct"
          }
        },
        "primary-category": {
          "description": "the id of the primary category for this packaged-product",
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "code",
        "size",
        "price",
        "tags"
      ]
    },
    "packagedProductProduct": {
      "description": "the name and brand of a product that a packaged-product is associated with",
      "type": "object",
      "properties": {
        "name": {
          "description": "the product name",
          "type": "string"
        },
        "brand": {
          "description": "the brand that this product is associated with",
          "schema": {
            "$ref": "#/definitions/brand"
          }
        }
      }
    },
    "packagedProductTag": {
      "description": "a type of packaged product or other boolean marker",
      "type": "object",
      "properties": {
        "slug": {
          "description": "code used as the primary key for tags",
          "type": "string"
        },
        "name": {
          "description": "human-readable tag name",
          "type": "string"
        },
        "category": {
          "description": "category code describing the type of tag",
          "type": "string",
          "enum": [
            "status",
            "price-level",
            "characteristic"
          ]
        }
      }
    },
    "packagedProductTagAssociation": {
      "description": "a packaged product tag representing a saved filter for a person",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "person": {
          "type": "integer",
          "format": "int64"
        },
        "tag": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "person",
        "tag"
      ]
    },
    "product": {
      "description": "a product available for sale (independent of packaging)",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "sentence-length product name",
          "type": "string"
        },
        "description": {
          "description": "long-form product description",
          "type": "string"
        },
        "brand": {
          "$ref": "#/definitions/brand"
        },
        "directions": {
          "description": "product use directions (e.g., cooking suggestions)",
          "type": "string"
        },
        "favorites": {
          "description": "number of people who've marked this product as a favorite",
          "type": "integer",
          "format": "int32"
        },
        "ingredients": {
          "description": "ingredients used in this product (e.g., \"dried cranberries (organic cranberries, organic cane sugar, organic sunflower oil)\")",
          "type": "string"
        },
        "nutrition-facts": {
          "$ref": "#/definitions/nutritionFacts"
        },
        "packaging": {
          "description": "packaged versions of this product",
          "type": "array",
          "items": {
            "$ref": "#/definitions/packagedProduct"
          }
        }
      },
      "required": [
        "id",
        "name",
        "size",
        "price",
        "packaging"
      ]
    },
    "nutritionFacts": {
      "description": "nutrition facts",
      "type": "object",
      "properties": {
        "headers": {
          "description": "nutrition-fact headers (e.g. \"Serving Size 1 cake (19g)\" or \"Calories 60\")",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "daily-values": {
          "description": "nutrition facts daily values",
          "type": "array",
          "items": {
            "$ref": "#/definitions/nutritionFactsDailyValue"
          }
        }
      }
    },
    "nutritionFactsDailyValue": {
      "description": "a nutrition facts daily value",
      "type": "object",
      "properties": {
        "indent": {
          "description": "if true, this label should be indented (e.g. an indented \"Dietary Fiber\" entry might follow a non-indented \"Total Carbohydrate\" entry)",
          "type": "boolean"
        },
        "label": {
          "description": "daily value label (e.g. \"Total Carbohydrate 14g\", \"Calcium\")",
          "type": "string"
        },
        "percentage": {
          "description": "daily value percentage (e.g., \"10\" or \"<1\")",
          "type": "string"
        }
      },
      "required": [
        "indent",
        "label",
        "percentage"
      ]
    },
    "brand": {
      "description": "a brand which may be associated with several products",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "url": {
          "description": "homepage for the brand",
          "type": "string",
          "format": "url"
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "_price": {
      "description": "a helper object for 'price'",
      "type": "object",
      "properties": {
        "dollars": {
          "description": "price of the product in dollars",
          "type": "number",
          "format": "float"
        },
        "per-pound": {
          "description": "whether the price is per-pound or per-unit",
          "type": "boolean"
        },
        "discount": {
          "description": "text for the discount (e.g. \"12%\", or \"$3.50\")",
          "type": "string"
        },
        "dollars-per-unit": {
          "description": "the per-unit price",
          "type": "number",
          "format": "float"
        },
        "unit": {
          "description": "The unit for the dollars-per-unit",
          "type": "string"
        }
      },
      "required": [
        "dollars"
      ]
    },
    "priceLevel": {
      "description": "a customer property to pick the right price from 'price'",
      "type": "string",
      "enum": [
        "retail",
        "wholesale",
        "member"
      ]
    },
    "permission": {
      "description": "an API authorization or authorization category",
      "type": "string",
      "enum": [
        "staff",
        "superuser"
      ]
    },
    "price": {
      "description": "product price information",
      "type": "object",
      "properties": {
        "retail": {
          "description": "pricing for retail customers",
          "schema": {
            "$ref": "#/definitions/_price"
          }
        },
        "wholesale": {
          "description": "pricing for wholesale customers",
          "schema": {
            "$ref": "#/definitions/_price"
          }
        },
        "member": {
          "description": "pricing for member customers",
          "schema": {
            "$ref": "#/definitions/_price"
          }
        }
      }
    },
    "category": {
      "description": "a category available for sale",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "A phrase naming the category.  This should be understandable (but not necessarily unique) without any further context.  It must be unique for categories sharing a given parent.",
          "type": "string"
        },
        "short-name": {
          "description": "A word or two naming the category.  A shortened version of the full name that drops any words already contained in the category's ancestors' short names.  This will be used in places where the ancestor short names are in close proximity (e.g. URL slugs) to avoid having the same word many times.",
          "type": "string"
        },
        "image": {
          "description": "A picture of this category.  Use base64 to upload new images, and leave unset to delete an existing image.  Invalid base64, including URLs containing colons and/or periods, will result in no change.",
          "type": "string"
        },
        "parent": {
          "description": "category ID for the parent category",
          "type": "integer",
          "format": "int64"
        },
        "primary": {
          "description": "denotes if this is a primary category",
          "type": "boolean"
        },
        "active": {
          "description": "denotes if this category is active",
          "type": "boolean"
        },
        "keywords": {
          "type": "array",
          "items": {
            "description": "a keyword for this category",
            "type": "string"
          }
        },
        "featured": {
          "description": "ordering precedence for likely customer interest.  Defaults to zero.",
          "type": "integer",
          "format": "int32"
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "order": {
      "description": "an order placed by a customer",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "customer": {
          "description": "customer making the order",
          "type": "integer",
          "format": "int64"
        },
        "status": {
          "description": "order's lifecycle stage",
          "type": "string",
          "enum": [
            "cart",
            "placed",
            "shipped",
            "lost"
          ]
        },
        "placed": {
          "description": "when the order was placed",
          "type": "string",
          "format": "date-time"
        },
        "shipped": {
          "description": "when the order was shipped",
          "type": "string",
          "format": "date-time"
        },
        "target-delivery": {
          "description": "planned delivery time (fixed before the trip starts, and unset for UPS orders)",
          "type": "string",
          "format": "date-time"
        },
        "estimated-delivery": {
          "description": "estimated delivery time (updated after the trip starts until the order is delivered, and unset for UPS orders)",
          "type": "string",
          "format": "date-time"
        },
        "delivered": {
          "description": "when the order was delivered",
          "type": "string",
          "format": "date-time"
        },
        "checkout-payment": {
          "description": "before shipping, the customer can use this to associate a payment-method with the order.  After shipping, it contains information about the charged payment",
          "$ref": "#/definitions/payment"
        },
        "fees": {
          "description": "additional charges beyond the order-line items themselves (estimated until picking time)",
          "type": "array",
          "items": {
            "$ref": "#/definitions/orderFee"
          }
        },
        "drop": {
          "description": "drop the order is destined for (unset for UPS orders)",
          "type": "integer",
          "format": "int64"
        },
        "trip": {
          "description": "trip delivering the order (unset for UPS orders)",
          "type": "integer",
          "format": "int64"
        },
        "address": {
          "description": "UPS delivery location (unset for truck orders)",
          "$ref": "#/definitions/address"
        }
      },
      "required": [
        "id",
        "customer",
        "status"
      ]
    },
    "orderLine": {
      "description": "a per-product entry in an order",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "order": {
          "description": "order that the order-line belongs to",
          "type": "integer",
          "format": "int64"
        },
        "packaged-product": {
          "description": "packaged product code that is being ordered",
          "type": "string"
        },
        "quantity-ordered": {
          "description": "number of product instances requested",
          "type": "integer",
          "format": "int32"
        },
        "quantity-shipped": {
          "description": "number of product instances delivered",
          "type": "integer",
          "format": "int32"
        },
        "weight": {
          "description": "weight of the shipped products in pounds (estimated until picking time)",
          "type": "number",
          "format": "float"
        },
        "volume": {
          "description": "volume of the shipped products in cubic feet (estimated until picking time)",
          "type": "number",
          "format": "float"
        },
        "price": {
          "description": "the total price for this line in dollars (estimated until picking time).  The per-unit price used to calculate this total is currently locked in when you place the order.",
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "id",
        "order",
        "packaged-product",
        "quantity-ordered",
        "weight",
        "volume"
      ]
    },
    "orderFee": {
      "description": "An additional charge associated with an order.",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "order": {
          "description": "Order that the fee belongs to",
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "Fee type slug",
          "$ref": "#/definitions/orderFeeType"
        },
        "amount": {
          "description": "Dollar value for the fee",
          "type": "number",
          "format": "float"
        },
        "notes": {
          "description": "Additional information about the reason or amount for the fee",
          "type": "string"
        }
      },
      "required": [
        "order",
        "type",
        "amount"
      ]
    },
    "orderFeeType": {
      "description": "A property for an order fee",
      "type": "string",
      "enum": [
        "shipping",
        "small-order"
      ]
    },
    "accountEntry": {
      "description": "an entry in a person's acount",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "person": {
          "description": "person associated with the account",
          "type": "integer",
          "format": "int64"
        },
        "amount": {
          "description": "dollar value for the entry (positive for credits like customer payments, negative for debits like order charges)",
          "type": "number",
          "format": "float"
        },
        "date": {
          "description": "when the entry was added",
          "type": "string",
          "format": "date"
        },
        "notes": {
          "description": "a line of Markdown identifying the entry (e.g. \"charge for order 123\" or \"payed with card ending in 0123\").",
          "type": "string"
        },
        "balance": {
          "description": "account balance after this account entry",
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "id",
        "person",
        "amount",
        "date"
      ]
    },
    "creditCard": {
      "description": "a credit card (one of our supported payment methods)",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "string identifying this payment model",
          "type": "string",
          "enum": [
            "credit-card"
          ]
        },
        "person": {
          "description": "person associated with this credit card",
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "billing name (which may differ from the associated person's name)",
          "type": "string"
        },
        "address": {
          "description": "billing address associated with this credit card",
          "$ref": "#/definitions/address"
        },
        "issuer": {
          "description": "provider network.  You can determine this from the leading digits of the card number, but we don't store those digits",
          "type": "string"
        },
        "last-four": {
          "description": "last four digits of the card number for identification",
          "type": "string"
        },
        "expiration": {
          "description": "expiration date.  We only use the month and year; the day will always be '01'.",
          "type": "string",
          "format": "date"
        }
      },
      "required": [
        "id",
        "type",
        "person",
        "name",
        "address",
        "last-four",
        "expiration"
      ]
    },
    "newCreditCard": {
      "description": "Azure does not store much credit card information internally (we use an external card processor), but we do need all of the information for the initial upload so we can pass it along to the external processor.",
      "type": "object",
      "properties": {
        "type": {
          "description": "string identifying this payment model",
          "type": "string",
          "enum": [
            "credit-card"
          ]
        },
        "person": {
          "description": "person associated with this credit card",
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "billing name (which may differ from the associated person's name)",
          "type": "string"
        },
        "address": {
          "description": "billing address associated with this credit card",
          "type": "integer",
          "format": "int64"
        },
        "number": {
          "description": "card number",
          "type": "string"
        },
        "security-code": {
          "description": "security code (also known as the verification value)",
          "type": "string"
        },
        "expiration": {
          "description": "expiration date.  We only use the month and year and ignore the day (which you should set to '01').",
          "type": "string",
          "format": "date"
        }
      },
      "required": [
        "type",
        "person",
        "name",
        "address",
        "number",
        "security-code",
        "expiration"
      ]
    },
    "payrollDeduction": {
      "description": "a payroll deduction (one of our supported payment methods)",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "string identifying this payment model",
          "type": "string",
          "enum": [
            "payroll-deduction"
          ]
        },
        "person": {
          "description": "person associated with this payroll deduction",
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "id",
        "type",
        "person"
      ]
    },
    "paymentMethod": {
      "anyOf": [
        {
          "$ref": "#definitions/creditCard"
        },
        {
          "$ref": "#definitions/payrollDeduction"
        }
      ]
    },
    "newPaymentMethod": {
      "anyOf": [
        {
          "$ref": "#definitions/newCreditCard"
        }
      ]
    },
    "payment": {
      "description": "A payment instance where an amount will be (or has been) charged via a payment-method.",
      "type": "object",
      "properties": {
        "payment-method": {
          "description": "Payment-method ID to use (or which was used)",
          "type": "integer",
          "format": "int64"
        },
        "amount": {
          "description": "Amount to charge (or which was charged) in dollars",
          "type": "number",
          "format": "float"
        },
        "paid": {
          "description": "Has the payment been charged?",
          "type": "boolean"
        }
      },
      "required": [
        "payment-method"
      ]
    },
    "registration": {
      "description": "A request for registering a new person",
      "type": "object",
      "properties": {
        "base-url": {
          "description": "Redirect URL for the confirmation UI.  The confirmation email points customers at {base-url}{confirmation-token} to confirm their registration.",
          "type": "string",
          "format": "url"
        },
        "person": {
          "description": "The registrant's personal information.  Name, email, and password are required.",
          "type": "object",
          "schema": {
            "$ref": "#/definitions/updatePerson"
          }
        },
        "address": {
          "description": "The registrant's mailing address (required if they've set person.catalog).",
          "type": "object",
          "schema": {
            "$ref": "#/definitions/address"
          }
        },
        "telephone": {
          "description": "The registrant's telephone numbers (currently only supports 'voice' and 'text' types)",
          "type": "array",
          "items": {
            "$ref": "#/definitions/telephone"
          }
        },
        "drop": {
          "description": "The registrant's chosen drop",
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "base-url",
        "person"
      ]
    },
    "resendRegistrationEmail": {
      "description": "A request for another registration email",
      "type": "object",
      "properties": {
        "base-url": {
          "description": "Redirect URL for the confirmation UI.  The confirmation email points customers at {base-url}{confirmation-token} to confirm their registration.",
          "type": "string",
          "format": "url"
        },
        "token": {
          "description": "The registrant's resend token",
          "type": "string"
        }
      },
      "required": [
        "base-url",
        "token"
      ]
    },
    "passwordResetRequest": {
      "description": "A request for a password-reset token",
      "type": "object",
      "properties": {
        "base-url": {
          "description": "Redirect URL for the password reset UI.  The password reset email points customers at {base-url}{confirmation-token} to confirm their password reset.",
          "type": "string",
          "format": "url"
        },
        "email": {
          "description": "The email address for the person whose password will be reset",
          "type": "string",
          "format": "email"
        }
      },
      "required": [
        "base-url",
        "email"
      ]
    },
    "passwordResetConfirmation": {
      "description": "A request to reset a password using a password-reset token",
      "type": "object",
      "properties": {
        "token": {
          "description": "The password-reset confirmation token",
          "type": "string"
        },
        "password": {
          "description": "The new password",
          "type": "string"
        }
      },
      "required": [
        "token",
        "password"
      ]
    },
    "notificationChannel": {
      "description": "channel technology for pushing user notifications",
      "type": "string",
      "enum": [
        "email",
        "text"
      ]
    },
    "telephone": {
      "description": "A telephone number",
      "type": "object",
      "properties": {
        "pref": {
          "description": "Mark a preferred-use telephone number (assumed false)",
          "type": "boolean"
        },
        "type": {
          "description": "An array of properties for this number",
          "type": "array",
          "items": {
            "$ref": "#/definitions/telephoneType"
          }
        },
        "number": {
          "description": "E.123 telephone number",
          "type": "string",
          "format": "telephone"
        }
      },
      "required": [
        "type",
        "number"
      ]
    },
    "telephoneType": {
      "description": "a property of a telephone number",
      "type": "string",
      "enum": [
        "text",
        "voice"
      ]
    },
    "person": {
      "description": "a person (customer, vendor, employee, ...)",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "email": {
          "type": "string",
          "format": "email"
        },
        "can-email": {
          "description": "Can Azure contact this person for reasons other than registration",
          "type": "boolean"
        },
        "catalog": {
          "description": "Set to true to receive the product catalog",
          "type": "boolean"
        },
        "company": {
          "description": "Employer name",
          "type": "string"
        },
        "allow-social-media": {
          "description": "Does this person want social media links to display",
          "type": "boolean"
        },
        "opt-in-beta-site": {
          "type": "boolean"
        },
        "price-level": {
          "$ref": "#/definitions/priceLevel"
        },
        "notifications": {
          "$ref": "#/definitions/personNotifications"
        },
        "permissions": {
          "description": "API permissions for this person",
          "type": "array",
          "items": {
            "$ref": "#/definitions/permission"
          }
        }
      },
      "required": [
        "id",
        "name",
        "notifications"
      ]
    },
    "updatePerson": {
      "description": "a person (customer, vendor, employee, ...)",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "password": {
          "description": "Password for authentication",
          "type": "string"
        },
        "email": {
          "type": "string",
          "format": "email"
        },
        "can-email": {
          "description": "Can Azure contact this person for reasons other than registration?  Defaults to true when creating a person",
          "type": "boolean"
        },
        "catalog": {
          "description": "Subscribed to receive the product catalog?  Defaults to false when creating a person",
          "type": "boolean"
        },
        "company": {
          "description": "Employer name",
          "type": "string"
        },
        "allow-social-media": {
          "description": "Does this person want social media links to display?  Defaults to true when creating a person",
          "type": "boolean"
        },
        "opt-in-beta-site": {
          "type": "boolean"
        },
        "notifications": {
          "$ref": "#/definitions/personNotifications"
        }
      }
    },
    "updatePersonUserPassword": {
      "description": "a person (customer, vendor, employee, ...) with the logged in user's password",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "password": {
          "description": "Password for authentication",
          "type": "string"
        },
        "email": {
          "type": "string",
          "format": "email"
        },
        "can-email": {
          "description": "Can Azure contact this person for reasons other than registration",
          "type": "boolean"
        },
        "catalog": {
          "description": "Subscribed to receive the product catalog",
          "type": "boolean"
        },
        "company": {
          "description": "Employer name",
          "type": "string"
        },
        "allow-social-media": {
          "description": "Does this person want social media links to display",
          "type": "boolean"
        },
        "opt-in-beta-site": {
          "type": "boolean"
        },
        "user-password": {
          "description": "The authenticated person's password, required when changing password or email",
          "type": "string"
        },
        "notifications": {
          "$ref": "#/definitions/personNotifications"
        }
      }
    },
    "personNotifications": {
      "description": "configure if and how a user receives per-user notifications",
      "type": "object",
      "properties": {
        "checkout": {
          "description": "sent after checking out orders.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        },
        "delivery": {
          "description": "sent after order delivery, and after updates to delivery estimates.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        },
        "payment": {
          "description": "sent after Azure processes a payment.",
          "format": "array",
          "items": {
            "$ref": "#definitions/notificationChannel"
          }
        },
        "invoice": {
          "description": "sent when new invoices are generated",
          "format": "array",
          "items": {
            "type": "string",
            "enum": [
              "paper",
              "email"
            ]
          }
        }
      }
    },
    "address": {
      "description": "an address following the convention of http://microformats.org/wiki/h-adr and https://tools.ietf.org/html/rfc6350#section-6.3.1, with an additional \"name\" property",
      "type": "object",
      "properties": {
        "name": {
          "description": "contact name for this address (e.g. \"Mr. John Q. Public, Esq.\")",
          "type": "string"
        },
        "post-office-box": {
          "type": "string"
        },
        "extended-address": {
          "type": "string"
        },
        "street-address": {
          "type": "string"
        },
        "locality": {
          "type": "string"
        },
        "region": {
          "type": "string"
        },
        "postal-code": {
          "type": "string"
        },
        "country-name": {
          "type": "string"
        },
        "preference": {
          "description": "ordering precedence for the findAddresses.  Defaults to zero.",
          "type": "integer",
          "format": "int32"
        }
      },
      "required": [
        "locality",
        "region",
        "country-name"
      ]
    },
    "location": {
      "description": "a named geographic coordinate with an enumerated label",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        },
        "geo": {
          "$ref": "#/definitions/geo"
        },
        "label": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "geo"
      ]
    },
    "geo": {
      "description": "a geographical coordinate",
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "float"
        },
        "longitude": {
          "type": "number",
          "format": "float"
        }
      },
      "required": [
        "latitude",
        "longitude"
      ]
    },
    "favorite": {
      "description": "a customer favorite",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "quantity": {
          "type": "integer",
          "format": "int64"
        },
        "packaged-product": {
          "type": "string"
        },
        "customer": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "id",
        "quantity",
        "packaged-product",
        "customer"
      ]
    },
    "updateFavorite": {
      "description": "a customer favorite",
      "type": "object",
      "properties": {
        "quantity": {
          "type": "integer",
          "format": "int64"
        },
        "packaged-product": {
          "type": "string"
        },
        "customer": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "quantity",
        "packaged-product",
        "customer"
      ]
    },
    "faq": {
      "description": "frequently asked question",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "question": {
          "description": "a frequently asked question in plain text.",
          "type": "string"
        },
        "answer": {
          "description": "the answer to the associated question in plain text.",
          "type": "string"
        },
        "order": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "id",
        "question",
        "answer",
        "order"
      ]
    },
    "updateFaq": {
      "description": "frequently asked question",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "question": {
          "description": "a frequently asked question in plain text.",
          "type": "string"
        },
        "answer": {
          "description": "the answer to the associated question in plain text.",
          "type": "string"
        },
        "order": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "question",
        "answer",
        "order"
      ]
    },
    "session": {
      "description": "session cookie information",
      "type": "object",
      "properties": {
        "person": {
          "description": "person ID for the session owner (unset for anonymous sessions)",
          "type": "integer",
          "format": "int64"
        },
        "expires": {
          "description": "current expiration date for this session (http://tools.ietf.org/html/rfc6265#section-5.3, covering both Max-Age and Expires representations, unset if the session expires at browser-close)",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "notification": {
      "description": "a notification to display on the website",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "message": {
          "type": "string"
        },
        "active": {
          "type": "boolean"
        },
        "dismissed": {
          "type": "boolean",
          "description": "if annotate-person is specified in the request, this field will note if the notification has been dismissed"
        }
      },
      "required": [
        "id",
        "message"
      ]
    },
    "notificationDismissal": {
      "description": "a dismissal used to hide a read notification",
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "notification": {
          "type": "integer",
          "format": "int64"
        },
        "person": {
          "type": "integer",
          "format": "int64"
        }
      },
      "required": [
        "notification",
        "person"
      ]
    },
    "productAudit": {
      "description": "an audited or auditable product and its packaging",
      "type": "object",
      "properties": {
        "id": {
          "description": "the product ID (not unique to the audit process)",
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "description": "sentence-length product name.  Copied from `#definitions/product` for easier UI development",
          "type": "string"
        },
        "packaging": {
          "description": "all related audited and/or non-audited packaged versions of this product",
          "type": "array",
          "items": {
            "$ref": "#/definitions/packagedProductAudit"
          }
        }
      },
      "required": [
        "id",
        "name",
        "packaging"
      ]
    },
    "packagedProductAudit": {
      "description": "an audited or auditable packaged-product",
      "type": "object",
      "properties": {
        "id": {
          "description": "the packaged-product id (not unique to the audit process)",
          "type": "string"
        },
        "size": {
          "description": "the old size of the product (e.g. \"12 oz.\" or \"6x12 oz.\")",
          "type": "string"
        },
        "packs": {
          "description": "the new dimensions of package sizes (e.g. \"4\", \"4x32.5\", or \"2x4x32.5\")",
          "type": "string"
        },
        "unit": {
          "description": "the new unit of measurement.  You can use any string, but the backend will only be able to make automatic comparisons if you use SI prefixes (e.g. \"mm\" for millimeters) and stick to the following base units: pound, ounce, gram, gallon, liter, quart, pint, cup, fluid ounce, yard, and count",
          "type": "string"
        },
        "audited": {
          "description": "a datetime denoting if and when the packaged-product was last audited",
          "type": "date-time"
        }
      },
      "required": [
        "id",
        "size",
        "packs",
        "unit",
        "audited"
      ]
    },
    "updatePackagedProductAudit": {
      "description": "an update to an audited packaged-product",
      "type": "object",
      "properties": {
        "packs": {
          "description": "the new dimensions of package sizes (e.g. \"4\", \"4x32.5\", or \"2x4x32.5\")",
          "type": "string"
        },
        "unit": {
          "description": "the new unit of measurement.  Ideally one of \"\", or \"\", but you can use another unit if none of those fit.",
          "type": "string"
        },
        "clear-audited": {
          "description": "If true, clear the audited date-time for this packaged-product.  If false (the default), set the audited date-time to the current time.",
          "type": "boolean"
        }
      },
      "required": [
        "packs",
        "unit"
      ]
    },
    "errorModel": {
      "required": [
        "code",
        "message"
      ],
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        }
      }
    }
  }
}
