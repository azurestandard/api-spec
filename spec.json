{
  "openapi": "3.0.0",
  "info": {
    "version": "1.0.0-oas3",
    "title": "Azure Standard Public API",
    "description": "The public API behind Azure's website.\n\nNotes: \n\n- Query parameter arrays should be formatted as comma-separated lists. Example:\n  ```\n  https://api.azurestandard.com/stops?inline=drop,pickup,truckloadId\n  ```\n",
    "contact": {
      "name": "Azure Standard Customer Service",
      "email": "info@azurestandard.com",
      "url": "https://azurestandard.com/customer-service"
    },
    "license": {
      "name": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  },
  "security": [
    {
      "basic": []
    },
    {
      "sessionCookie": []
    }
  ],
  "paths": {
    "/affiliate-referrals": {
      "get": {
        "summary": "Returns all affiliate referrals for the given referring user, in descending order of the date the referred person's account was created",
        "operationId": "findAffiliateReferrals",
        "tags": [
          "affiliate-referral"
        ],
        "parameters": [
          {
            "name": "person",
            "in": "query",
            "description": "Person ID of the referring user.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Affiliate referral response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/affiliateReferral"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/bartender-hosts": {
      "get": {
        "summary": "Returns all BarTender hosts from the system that the user has access to",
        "operationId": "findBartenderHosts",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BartenderHost response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/bartenderHost"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new BarTender host",
        "operationId": "addBartenderHost",
        "tags": [
          "bartender"
        ],
        "responses": {
          "200": {
            "description": "BarTender host response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderHost"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bartenderHost"
              }
            }
          },
          "description": "BarTender host to add.",
          "required": true
        }
      }
    },
    "/bartender-host/{code}": {
      "get": {
        "summary": "Returns a BarTender host based on a single code, if the user has access to it",
        "operationId": "findBartenderHostByCode",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "Code of BarTender host to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender host response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderHost"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing BarTender host",
        "operationId": "updateBartenderHost",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "Code of BarTender host to update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender host response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderHost"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bartenderHost"
              }
            }
          },
          "description": "Updated BarTender host parameters (can optionally include 'code').",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing BarTender host",
        "operationId": "deleteBartenderHost",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "Code of BarTender host to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/bartender-templates": {
      "get": {
        "summary": "Returns all BarTender templates from the system that the user has access to",
        "operationId": "findBartenderTemplates",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BartenderTemplate response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/bartenderTemplate"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new BarTender template",
        "operationId": "addBartenderTemplate",
        "tags": [
          "bartender"
        ],
        "responses": {
          "200": {
            "description": "BarTender template response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderTemplate"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bartenderTemplate"
              }
            }
          },
          "description": "BarTender template to add.",
          "required": true
        }
      }
    },
    "/bartender-template/{id}": {
      "get": {
        "summary": "Returns a BarTender template based on a single ID, if the user has access to it",
        "operationId": "findBartenderTemplateById",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender template to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender template response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderTemplate"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing BarTender template",
        "operationId": "updateBartenderTemplate",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender template to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender template response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderTemplate"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bartenderTemplate"
              }
            }
          },
          "description": "Updated BarTender template parameters (can optionally include 'id').",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing BarTender template",
        "operationId": "deleteBartenderTemplate",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender template to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/bartender-print-configurations": {
      "get": {
        "summary": "Returns all BarTender print configurations from the system that the user has access to",
        "operationId": "findBartenderPrintConfigurations",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BartenderPrintConfiguration response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/bartenderPrintConfiguration"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new BarTender print configuration",
        "operationId": "addBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "responses": {
          "200": {
            "description": "BarTender print configuration response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderPrintConfiguration"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bartenderPrintConfiguration"
              }
            }
          },
          "description": "BarTender print configuration to add.",
          "required": true
        }
      }
    },
    "/bartender-print-configuration/{id}": {
      "get": {
        "summary": "Returns a BarTender print configuration based on a single ID, if the user has access to it",
        "operationId": "findBartenderPrintConfigurationById",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender print configuration response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderPrintConfiguration"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing BarTender print configuration",
        "operationId": "updateBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "BarTender print configuration response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/bartenderPrintConfiguration"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/bartenderPrintConfiguration"
              }
            }
          },
          "description": "Updated BarTender print configuration parameters (can optionally include 'id').",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing BarTender print configuration",
        "operationId": "deleteBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/bartender-print-configuration/{id}/actions/test-print": {
      "post": {
        "summary": "Create a test BarTender print request",
        "description": "Create a test BarTender print request using this print configuration. The print request uses hard-coded dummy data if a stock ID is not provided.",
        "operationId": "actionTestBartenderPrintConfiguration",
        "tags": [
          "bartender"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of BarTender print configuration to test.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "BarTender print configuration test print request accepted."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "stock": {
                    "type": "integer",
                    "format": "int64"
                  }
                }
              }
            }
          },
          "description": "Test data to use in the test print request. The payload must be a JSON object, but the `stock` property is optional.",
          "required": true
        }
      }
    },
    "/brands": {
      "get": {
        "summary": "Returns all brands (no authorization required)",
        "operationId": "findBrands",
        "tags": [
          "brand"
        ],
        "security": [],
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "description": "Only return brands whose name contains this value (case insensitive).",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "int32"
                },
                {
                  "type": "string",
                  "enum": [
                    "none"
                  ]
                }
              ]
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Brand response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you set `limit` to `none`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/brand"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/brand/{id}": {
      "get": {
        "summary": "Returns a brand (no authorization required)",
        "operationId": "findBrandById",
        "tags": [
          "brand"
        ],
        "security": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of brand to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Brand response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/brand"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/company-directory": {
      "get": {
        "summary": "Search company directory",
        "operationId": "findCompanyDirectoryEntries",
        "tags": [
          "company-directory"
        ],
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "description": "Query to perform within the directory. The use of a `*` at the beginning or end of the string is treated as a wildcard. This parameter is case insensitive.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "query-field",
            "in": "query",
            "description": "Fields to search. Any property included in a companyDirectoryEntry response may be queried. Defaults to `full-name`, `first-name`, `last-name`, `title`, `department.name`, `phone-number`, `phone-ext`, `mobile`, `email`, and `office`.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "department",
            "in": "query",
            "description": "Filter by department. If this parameter is used then department will be ignored in the query-field parameter. This parameter is case insensitive.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Order results by this field. Any property included in a companyDirectoryEntry response may be used here. Defaults to `department.name`, `first-name` and `last-name`.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "CompanyDirectoryEntry response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/companyDirectoryEntry"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/company-directory-departments": {
      "get": {
        "summary": "Returns all departments in the company directory",
        "operationId": "findDepartments",
        "tags": [
          "company-directory"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Department response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/department"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/reports": {
      "get": {
        "summary": "Returns all reports from the system that the user has access to",
        "operationId": "findReports",
        "tags": [
          "report"
        ],
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "description": "Query terms to filter by (currently searches `name` only).",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "category",
            "in": "query",
            "description": "Report category IDs to filter by. `null` may be used to return reports that are uncategorized.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Report response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/report"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/report/{id}": {
      "get": {
        "summary": "Returns a report based on an ID, if the user has access to it",
        "operationId": "findReportById",
        "tags": [
          "report"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of report to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Report response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/report"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/report-categories": {
      "get": {
        "summary": "Returns all report categories from the system that the user has access to",
        "operationId": "findReportCategories",
        "tags": [
          "report"
        ],
        "parameters": [
          {
            "name": "customer-pricing",
            "in": "query",
            "description": "Filter categories by whether or not they contain customer pricing groups.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ReportCategory response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/reportCategory"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new report category",
        "operationId": "addReportCategory",
        "tags": [
          "report"
        ],
        "responses": {
          "200": {
            "description": "Report category response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/reportCategory"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/reportCategory"
              }
            }
          },
          "description": "Report category to add.",
          "required": true
        }
      }
    },
    "/report-category/{id}": {
      "get": {
        "summary": "Returns a report category based on an ID, if the user has access to it",
        "operationId": "findReportCategoryById",
        "tags": [
          "report"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of report category to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Report category response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/reportCategory"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing report category",
        "operationId": "updateReportCategory",
        "tags": [
          "report"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of report category to update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ReportCategory response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/reportCategory"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/reportCategory"
              }
            }
          },
          "description": "Updated report category parameters.",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing report category",
        "operationId": "deleteReportCategory",
        "tags": [
          "report"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of report category to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/drops": {
      "get": {
        "summary": "Returns all drops from the system that the user has access to",
        "operationId": "findDrops",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "Only return (in)active drops.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "exclusivity",
            "in": "query",
            "description": "Types of exclusivity to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "open",
                  "semi-open",
                  "closed"
                ]
              }
            }
          },
          {
            "name": "route",
            "in": "query",
            "description": "Route names to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "trip",
            "in": "query",
            "description": "Trip IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Order results by this field. Only one special sort field is supported, distance(lat:45.45|lon:-121.13), which will sort drops by increasing distance from the lat and lon combination.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Drop response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/drop"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new drop",
        "operationId": "addDrop",
        "tags": [
          "drop"
        ],
        "responses": {
          "200": {
            "description": "Drop response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/drop"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/newDrop"
              }
            }
          },
          "description": "Drop to add.",
          "required": true
        }
      }
    },
    "/drop/{id}": {
      "get": {
        "summary": "Returns a drop based on a single ID, if the user has access to the drop",
        "operationId": "findDropById",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Drop response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/drop"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing drop",
        "operationId": "updateDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Drop response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/drop"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateDrop"
              }
            }
          },
          "description": "Updated drop parameters (can optionally include 'id').",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing drop",
        "operationId": "deleteDrop",
        "tags": [
          "drop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/drops/locations": {
      "get": {
        "summary": "Returns an array of locations for all active drops that the user has access to",
        "description": "For example, you can use this to draw markers on map.",
        "operationId": "findDropLocations",
        "tags": [
          "drop"
        ],
        "responses": {
          "200": {
            "description": "Drop locations response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/location"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/drop-memberships": {
      "get": {
        "summary": "Returns all drop memberships from the system that the user has access to",
        "operationId": "findDropMemberships",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "Only return (in)active memberships.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "drop",
            "in": "query",
            "description": "Drop IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "pending",
            "in": "query",
            "description": "Only return pending (true) or accepted (false) memberships.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"customer\", \"customer.email\", \"drop\", and \"gratitude-total\".",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Order results by this field. Supported fields: `customer.name`, `drop.name`.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "schema": {
              "type": "boolean"
            },
            "in": "query",
            "name": "customerHasPlacedOrderOnDrop",
            "description": "Return only drop memberships where the customer has placed an order on the drop. \n\nNotes: \n- Only supported when filtering for a single drop.\n- Does not support passing `false` (value must be `true`)."
          }
        ],
        "responses": {
          "200": {
            "description": "Drop membership response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/dropMembership"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new drop membership",
        "operationId": "addDropMembership",
        "tags": [
          "drop-membership"
        ],
        "responses": {
          "200": {
            "description": "Drop membership response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dropMembership"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/newDropMembership"
              }
            }
          },
          "description": "Drop membership to add.",
          "required": true
        }
      }
    },
    "/drop-membership/{id}": {
      "get": {
        "summary": "Returns a drop membership based on a single membership ID, if the user has access",
        "operationId": "findDropMembershipById",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"customer\", \"drop\", and \"gratitude-total\".",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Drop membership response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dropMembership"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing drop membership if the user has the access",
        "operationId": "updateDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Drop membership response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dropMembership"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateDropMembership"
              }
            }
          },
          "description": "Updated drop membership parameters.",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing drop membership",
        "operationId": "deleteDropMembership",
        "tags": [
          "drop-membership"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of drop membership to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/files": {
      "get": {
        "summary": "Returns all files from the system that the user has access to",
        "operationId": "findFiles",
        "tags": [
          "file"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you didn't set `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/file"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new file",
        "operationId": "addFile",
        "tags": [
          "file"
        ],
        "responses": {
          "200": {
            "description": "File response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/file"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "string"
              }
            }
          },
          "description": "File to add. The payload is the raw content, not a JSON object."
        }
      }
    },
    "/file/{id}": {
      "delete": {
        "summary": "Delete an existing file",
        "description": "Note: This may fail if there are any internal references to the file.",
        "operationId": "deleteFile",
        "tags": [
          "file"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of the file to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/pickups": {
      "get": {
        "summary": "Returns all pickups from the system that the user has access to",
        "operationId": "findPickups",
        "tags": [
          "pickup"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "Only return (in)active pickups.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "route",
            "in": "query",
            "description": "Route names to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "trip",
            "in": "query",
            "description": "Trip IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "vendor",
            "in": "query",
            "description": "Vendor IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pickup response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you didn't set `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/pickup"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/pickup/{id}": {
      "get": {
        "summary": "Returns a pickup based on a single ID, if the user has access to the pickup",
        "operationId": "findPickupById",
        "tags": [
          "pickup"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of pickup to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pickup response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pickup"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/routes": {
      "get": {
        "summary": "Returns all routes from the system that the user has access to",
        "operationId": "findRoutes",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "Drop IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Route response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/route"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new route",
        "operationId": "addRoute",
        "tags": [
          "route"
        ],
        "responses": {
          "200": {
            "description": "Route response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/route"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/newRoute"
              }
            }
          },
          "description": "Route to add.",
          "required": true
        }
      }
    },
    "/route/{name}": {
      "get": {
        "summary": "Returns a route based on a single ID, if the user has access to the route",
        "operationId": "findRouteById",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "Name of route to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Route response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/route"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing route",
        "operationId": "updateRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "Name of route to update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Route response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/route"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateRoute"
              }
            }
          },
          "description": "Update route parameters.",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing route",
        "operationId": "deleteRoute",
        "tags": [
          "route"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "Name of route to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/trips": {
      "get": {
        "summary": "Returns all trips from the system that the user has access to",
        "description": "Trips are ordered for decreasing cutoff time.",
        "operationId": "findTrips",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "Route names to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "drop",
            "in": "query",
            "description": "Drop IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "stop",
            "in": "query",
            "description": "Stop IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "cutoff-after",
            "in": "query",
            "description": "Only return trips with cutoffs after or on this date.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "cutoff-before",
            "in": "query",
            "description": "Only return trips with cutoffs before this date.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "confirmed",
            "in": "query",
            "description": "Only return (un)confirmed trips.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "schema": {},
            "in": "query",
            "name": "inline",
            "description": "For convenience, include additional information. Currently supports \"truckloads\" as described in the trip model."
          }
        ],
        "responses": {
          "200": {
            "description": "Trip response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/trip"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Creates a trip for a route, if the user has permissions",
        "operationId": "addTrip",
        "tags": [
          "trip"
        ],
        "responses": {
          "200": {
            "description": "Trip response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trip"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateTrip"
              }
            }
          },
          "description": "Trip to create.",
          "required": true
        }
      }
    },
    "/trip/{id}": {
      "get": {
        "summary": "Returns a trip based on a single ID, if the user has access to the trip",
        "operationId": "findTripById",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "schema": {
              "type": "array"
            },
            "in": "query",
            "name": "inline",
            "description": "For convenience, include additional information. Currently supports \"truckloads\" as described in the trip model."
          }
        ],
        "responses": {
          "200": {
            "description": "Trip response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trip"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Updates a trip for a route, if the user has permissions",
        "operationId": "updateTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Trip response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trip"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateTrip"
              }
            }
          },
          "description": "Trip to update.",
          "required": true
        }
      },
      "delete": {
        "summary": "Deletes a trip for a route, if the user has permissions",
        "operationId": "deleteTrip",
        "tags": [
          "trip"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of trip to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/stops": {
      "get": {
        "summary": "Returns all stops from the system that the user has access to",
        "description": "Stops are ordered for decreasing target time.",
        "operationId": "findStops",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "route",
            "in": "query",
            "description": "Route names to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "trip",
            "in": "query",
            "description": "Trip IDs names to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "drop",
            "in": "query",
            "description": "Drop IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "pickup",
            "in": "query",
            "description": "Pickup IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "estimatedDeliveryAfter",
            "in": "query",
            "description": "Only return stops with an estimated time after or on this date.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "estimatedDeliveryBefore",
            "in": "query",
            "description": "Only return stops with an estimated time before this date.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "short-drop",
            "in": "query",
            "description": "Only return stops which have (not) had short-drop warnings sent.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "truckloadId",
            "in": "query",
            "description": "Truckload (pickset) ID to filter by.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "$ref": "#/components/parameters/stopInline"
          }
        ],
        "responses": {
          "200": {
            "description": "Stop response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/stop"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new stop on a trip",
        "operationId": "addStop",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "persist",
            "in": "query",
            "description": "If true, calculate the offset between the trip's delivery start and this stop's estimated time. For any pre-cutoff trips associated with this stop's trip's route which cutoff later than this stop's trip, create a stop for this location (drop or pickup) if it does not already exist and update that stop's target and estimated times to have the same offset from that stop's trip's delivery start. Also create a route-stop association, if it does not already exist, for this location on this stop's trip's route and update that route-stop with the same delivery offset. API users should always pass `persist=true` if there are estimated delivery changes. For finalized and/or actual delivery changes, passing `persist=true` will not actually persist them but will slow down the response.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Stop response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stop"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateStop"
              }
            }
          },
          "description": "Stop to add.",
          "required": true
        }
      }
    },
    "/stop/{id}": {
      "get": {
        "summary": "Returns a stop based on a single ID, if the user has access to the stop",
        "operationId": "findStopById",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of stop to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "$ref": "#/components/parameters/stopInline"
          }
        ],
        "responses": {
          "200": {
            "description": "Stop response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stop"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing stop",
        "operationId": "updateStop",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of stop to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "persist",
            "in": "query",
            "description": "This option is only relevant for estimated delivery changes on future trips. If true, calculate the offset between the trips's delivery start and this stop's estimated time. For any pre-cutoff trips associated with this stop's trip's route which cutoff later than this stop's trip, create a stop for this location (drop or pickup) if it does not already exist and update that stop's target and estimated times to have the same offset from that stops's trip's delivery start. Also create a route-stop association, if it does not already exist, for this location on this stop's trip's route and update that route-stop with the same delivery offset. If propagate is set, apply the persistance logic to the later stops on the trip as well. For finalized and/or actual delivery changes, passing `persist=true` will not actually persist them but will slow down the response.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagate",
            "in": "query",
            "description": "If true, calculate the change from the existing estimated time. Shift the estimated time of all later stops on the trip by the same amount. For pre-cutoff trips, also shift the target times.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Stop response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stop"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateStop"
              }
            }
          },
          "description": "Stop to update.",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing stop",
        "operationId": "deleteStop",
        "tags": [
          "stop"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of stop to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "persist",
            "in": "query",
            "description": "If true, for any pre-cutoff trips associated with this stop's trip's route which cutoff later than this stop's trip, delete any stops for this location (drop or pickup). Also delete any route-stop associations for this location on this stop's trip's route.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "patch": {
        "summary": "Partially update an existing stop.",
        "operationId": "partiallyUpdateStop",
        "tags": [
          "stop"
        ],
        "description": "The stop to partially update.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of the stop to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "in": "query",
            "name": "persist",
            "description": "If true, calculate the offset between the trip's delivery start and this stop's estimated time. For any pre-cutoff trips associated with this stop's trip's route which cutoff later than this stop's trip, create a stop for this location (drop or pickup) if it does not already exist and update that stop's target and estimated times to have the same offset from that stops's trip's delivery start. Also create a route-stop association, if it does not already exist, for this location on this stop's trip's route and update that route-stop with the same delivery offset. If propagate is set, apply the persistence logic to the later stops on the trip as well. API users  should always pass `persist=true` if there are estimated delivery changes. For  finalized and/or actual delivery changes, passing `persist=true` will not actually  persist them but will slow down the response.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stop"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/partiallyUpdateStop"
              }
            }
          }
        }
      }
    },
    "/truckloads": {
      "get": {
        "summary": "Returns all truckloads (picksets) from the system that the user has access to",
        "description": "Truckloads (picksets) are ordered by truck number.",
        "operationId": "findTruckloads",
        "tags": [
          "truckload"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Truckload response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/truckload"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/truckload/{id}": {
      "get": {
        "summary": "Returns a truckload (pickset) based on a single ID, if the user has access to it",
        "operationId": "findTruckloadById",
        "tags": [
          "truckload"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of truckload (pickset) to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Truckload response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/truckload"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Updates a truckload (pickset), if the user has permissions",
        "operationId": "updateTruckload",
        "tags": [
          "truckload"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of truckload (pickset) to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Truckload response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/truckload"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateTruckload"
              }
            }
          },
          "description": "Truckload to update.",
          "required": true
        }
      }
    },
    "/audit/products": {
      "get": {
        "summary": "Returns all products and their packaging from the system (for audit)",
        "operationId": "findProductAudits",
        "tags": [
          "audit"
        ],
        "parameters": [
          {
            "name": "audited",
            "in": "query",
            "description": "Filter for products that have or haven't been audited. When set, only products that contain (un)audited packaging are returned, and their packaging array only contains (un)audited packaging.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "search",
            "in": "query",
            "description": "Search string for filtering products. The logic behind this is left up to the implementation, but it should at least match words in the product name, and may optionally match the product description or other characteristics.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "Packaged-product codes to filter by.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Product audit response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/productAudit"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/audit/product/{id}": {
      "get": {
        "summary": "Returns a product based on a single ID (for audit)",
        "operationId": "findProductAuditById",
        "tags": [
          "audit"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of product to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "audited",
            "in": "query",
            "description": "When set, the packaging array only contains (un)audited packaging.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Product audit response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productAudit"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/audit/packaged-product/{id}": {
      "post": {
        "summary": "Audit an existing packaged-product",
        "operationId": "updatePackagedProductAudit",
        "tags": [
          "audit"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Id of packaged product being audited.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Packaged-product audit response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/packagedProductAudit"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updatePackagedProductAudit"
              }
            }
          },
          "description": "Packaged product to update.",
          "required": true
        }
      }
    },
    "/products": {
      "get": {
        "summary": "Returns all products from the system that the user has access to",
        "operationId": "findProducts",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "search",
            "in": "query",
            "description": "Search string for filtering products. The logic behind this is left up to the implementation, but it should at least match words in the product name, and may optionally match the product description or other characteristics.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gtin13",
            "in": "query",
            "description": "Packaged-product 13-digit Global Trade Item Numbers to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "brand",
            "in": "query",
            "description": "Brand IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "category",
            "in": "query",
            "description": "Category IDs to filter by (for products directly associated with the categories).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "primary-category",
            "in": "query",
            "description": "Primary-category IDs to filter by (for products directly associated with the categories).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "ancestor-category",
            "in": "query",
            "description": "Category IDs to filter by (for products associated with the categories or their descendants).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "Packaged product codes to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "tag",
            "in": "query",
            "description": "Tags to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by (selects their favorite products).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "Person ID for associating additional metadata with results (e.g. whether this person has favorited a given packaged-product). If unset and you're authenticated, defaults to your authenticated ID.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports the local \"description\", \"favorites\", and \"substitutions\" as well as \"brand\", \"packaging\", \"vendors\", and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Product response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/product"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/product/{id}": {
      "get": {
        "summary": "Returns a product based on a single ID, if the user has access to the product",
        "operationId": "findProductById",
        "tags": [
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of product to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports the local \"description\", \"favorites\", and \"substitutions\" as well as \"brand\", \"packaging\", \"vendors\", and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Product response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/product"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/packaged-products": {
      "get": {
        "summary": "Returns all packaged products from the system that the user has access to",
        "operationId": "findPackagedProduct",
        "tags": [
          "packaged-product"
        ],
        "parameters": [
          {
            "name": "product",
            "in": "query",
            "description": "Product IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "code",
            "in": "query",
            "description": "Packaged product codes to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "gtin13",
            "in": "query",
            "description": "13-digit Global Trade Item Numbers to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "brand",
            "in": "query",
            "description": "Brand IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "category",
            "in": "query",
            "description": "Category IDs to filter by (for products directly associated with the categories).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "primary-category",
            "in": "query",
            "description": "Primary-category IDs to filter by (for products directly associated with the categories).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "ancestor-category",
            "in": "query",
            "description": "Category IDs to filter by (for packaged products associated with the categories or their descendants).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "tag",
            "in": "query",
            "description": "Tags to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by (selects their favorite packaged products).",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "Person ID for associating additional metadata with results (e.g. whether this person has favorited a given packaged-product). If unset and you're authenticated, defaults to your authenticated ID.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "$ref": "#/components/parameters/packagedProductInline"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Packaged product response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/packagedProduct"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/packaged-product/{code}": {
      "get": {
        "summary": "Returns a packaged product based on a single ID, if the user has access to the packaged product",
        "operationId": "findPackagedProductById",
        "tags": [
          "packaged-product"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "Code of the packaged product to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/packagedProductInline"
          }
        ],
        "responses": {
          "200": {
            "description": "Product response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/packagedProduct"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/packaged-product-images": {
      "get": {
        "summary": "Returns all packaged product images from the system that the user has access to",
        "operationId": "findPackagedProductImages",
        "tags": [
          "packaged-product-image"
        ],
        "parameters": [
          {
            "name": "packaged-product",
            "in": "query",
            "description": "Packaged product codes to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Packaged product image response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/packagedProductImage"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Add a packaged product image",
        "operationId": "addPackagedProductImage",
        "tags": [
          "packaged-product-image"
        ],
        "responses": {
          "200": {
            "description": "Packaged product tag association response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/packagedProductImage"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/packagedProductImage"
              }
            }
          },
          "description": "Packaged product image to add.",
          "required": true
        }
      }
    },
    "/packaged-product-image/{id}": {
      "get": {
        "summary": "Returns a packaged product image based on a single ID, if the user has access to that object",
        "operationId": "findPackagedProductImageById",
        "tags": [
          "packaged-product-image"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of packaged product image to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Packaged product image response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/packagedProductImage"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update a packaged product image",
        "operationId": "updatePackagedProductImage",
        "tags": [
          "packaged-product-image"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of packaged product image to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Packaged product image response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/packagedProductImage"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/packagedProductImage"
              }
            }
          },
          "description": "Packaged product image to update.",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete a packaged product image",
        "operationId": "deletePackagedProductImage",
        "tags": [
          "packaged-product-image"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Packaged product image to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/packaged-product-tags": {
      "get": {
        "summary": "Returns all packaged product tags from the system that the user has access to",
        "operationId": "findPackagedProductTag",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "internal",
            "in": "query",
            "description": "If true, only return internal tags (that the user has access to). If false, only return public tags (regardless of the user's access to internal tags). If unset, don't filter based on the tag visibility.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "category",
            "in": "query",
            "description": "Categories to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Packaged product tag response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/packagedProductTag"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/packaged-product-tag-associations": {
      "get": {
        "summary": "Return packaged product tag filter preferences for a person",
        "operationId": "findPackagedProductTagAssociations",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person ID to filter by.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Packaged product tag association response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/packagedProductTagAssociation"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Add a tag to a person's packaged product tag filter preferences",
        "operationId": "addPackagedProductTagAssociation",
        "tags": [
          "packaged-product-tag"
        ],
        "responses": {
          "200": {
            "description": "Packaged product tag association response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/packagedProductTagAssociation"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/packagedProductTagAssociation"
              }
            }
          },
          "description": "Packaged-product tag association to add.",
          "required": true
        }
      }
    },
    "/packaged-product-tag-association/{id}": {
      "delete": {
        "summary": "Delete a packaged product tag association from a person's filter preferences",
        "operationId": "deletePackagedProductTagAssociation",
        "tags": [
          "packaged-product-tag"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Packaged product tag association ID to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/categories": {
      "get": {
        "summary": "Returns all categories from the system, ordered by decreasing `featured` values",
        "operationId": "findCategories",
        "tags": [
          "category"
        ],
        "security": [],
        "parameters": [
          {
            "name": "parent",
            "in": "query",
            "description": "Category IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "active",
            "in": "query",
            "description": "Only return (in)active categories.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "product",
            "in": "query",
            "description": "Product IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "Packaged product codes to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports `ancestors` and `depth`.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Category response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/category"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new category",
        "operationId": "createCategory",
        "tags": [
          "category"
        ],
        "responses": {
          "200": {
            "description": "Category response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/category"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateCategory"
              }
            }
          },
          "description": "Category to create.",
          "required": true
        }
      }
    },
    "/category/{id}": {
      "get": {
        "summary": "Returns a category based on a single ID",
        "operationId": "findCategoryById",
        "tags": [
          "category"
        ],
        "security": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of category to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"ancestors\" and \"depth\".",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Category response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/category"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update a category",
        "operationId": "updateCategory",
        "tags": [
          "category"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of category to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Category response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/category"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateCategory"
              }
            }
          },
          "description": "Category to update.",
          "required": true
        }
      }
    },
    "/purchases": {
      "get": {
        "summary": "Returns all purchases from the system that the user has access to",
        "description": "Purchases are ordered for increasing ID (creation time).",
        "operationId": "findPurchases",
        "tags": [
          "purchase"
        ],
        "parameters": [
          {
            "name": "vendor",
            "in": "query",
            "description": "Vendor IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "pickup",
            "in": "query",
            "description": "Pickup IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "trip",
            "in": "query",
            "description": "Trip IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Purchase-status string to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "open",
                  "submitted",
                  "confirmed",
                  "shipped",
                  "delivered",
                  "reconciled",
                  "paid"
                ]
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Purchase response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you didn't set `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/purchase"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/purchase/{id}": {
      "get": {
        "summary": "Returns a purchase based on a single ID",
        "operationId": "findPurchaseById",
        "tags": [
          "purchase"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of purchase to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Purchase response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/purchase"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/orders": {
      "get": {
        "summary": "Get all orders",
        "description": "Only returns orders that the user has access to.",
        "operationId": "findOrders",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "username",
            "in": "query",
            "description": "Usernames to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "email",
            "in": "query",
            "description": "Email addresses to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "email"
              }
            }
          },
          {
            "name": "drop",
            "in": "query",
            "description": "Drop IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "trip",
            "in": "query",
            "description": "Trip IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "product",
            "in": "query",
            "description": "Product IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "Packaged product codes to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Order-status string to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "open",
                  "placed",
                  "confirmed",
                  "shipped",
                  "lost"
                ]
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "truckloadId",
            "in": "query",
            "description": "Truckload (pickset) ID to filter by.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "$ref": "#/components/parameters/orderInline"
          }
        ],
        "responses": {
          "200": {
            "description": "Order response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/order"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new order",
        "operationId": "addOrder",
        "tags": [
          "order"
        ],
        "responses": {
          "200": {
            "description": "Order response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/order"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateOrder"
              }
            }
          },
          "description": "Order to add.",
          "required": true
        }
      }
    },
    "/order/{id}": {
      "get": {
        "summary": "Get single order by ID",
        "operationId": "findOrderById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "accept",
            "in": "query",
            "description": "Override the HTTP Accept header to chose the response type. Empty and unrecognized values will result in application/json.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/orderInline"
          }
        ],
        "responses": {
          "200": {
            "description": "Order response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/order"
                }
              },
              "application/pdf": {
                "schema": {
                  "$ref": "#/components/schemas/order"
                }
              },
              "text/csv": {
                "schema": {
                  "$ref": "#/components/schemas/order"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              },
              "application/pdf": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              },
              "text/csv": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing order",
        "operationId": "updateOrderById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "save",
            "in": "query",
            "description": "Whether to save the result of the PUT or not (defaults to true). Set to false if you want to preview the side-effects of a change before going through with an update.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/changedOrder"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateOrder"
              }
            }
          },
          "description": "Updated order parameters (can optionally include 'id').",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing order",
        "operationId": "deleteOrder",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/order-lines": {
      "get": {
        "summary": "Returns all order-lines from the system that the user has access to",
        "operationId": "findOrderLines",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "order",
            "in": "query",
            "description": "Order IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "product",
            "in": "query",
            "description": "Product IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "packaged-product",
            "in": "query",
            "description": "Packaged product codes to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order-line response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/orderLine"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new order-line",
        "operationId": "addOrderLine",
        "tags": [
          "order"
        ],
        "responses": {
          "200": {
            "description": "Order-line response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orderLine"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateOrderLine"
              }
            }
          },
          "description": "Order-line to add.",
          "required": true
        }
      }
    },
    "/order-line/{id}": {
      "get": {
        "summary": "Returns an order-line based on a single ID",
        "operationId": "findOrderLineById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order-line to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order-line response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orderLine"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing order-line",
        "operationId": "updateOrderLine",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order-line to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order-line response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orderLine"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateOrderLine"
              }
            }
          },
          "description": "Updated order-line parameters (can optionally include 'id').",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing order-line",
        "operationId": "deleteOrderLine",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order-line to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/order-fees": {
      "get": {
        "summary": "Returns all order fees from the system that the user has access to",
        "operationId": "findOrderFees",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "order",
            "in": "query",
            "description": "Order IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order fee response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/orderFee"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/order-fee/{id}": {
      "get": {
        "summary": "Returns an order fee based on a single ID",
        "operationId": "findOrderFeeById",
        "tags": [
          "order"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order fee to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order fee response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orderFee"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/order/{id}/parcel-carrier-fee-estimates": {
      "get": {
        "summary": "Returns all parcel carrier shipping options and their costs for an order ID",
        "operationId": "listOrderParcelCarrier",
        "tags": [
          "order",
          "parcel-carrier"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of order to retrieve parcel carrier options for.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order parcel carrier estimate response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/orderParcelCarrierEstimate"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/vendors": {
      "get": {
        "summary": "Returns all vendors from the system that the user has access to",
        "description": "Vendors are ordered for increasing ID (creation time).",
        "operationId": "findVendors",
        "tags": [
          "vendor"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "Only return (in)active vendors.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "manager",
            "in": "query",
            "description": "Person IDs to filter by, selecting vendors that these vendor employees manage.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "buyer",
            "in": "query",
            "description": "Person IDs to filter by, selecting vendors that these Azure employees buy from.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Vendor response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you didn't set `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/vendor"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/vendor/{id}": {
      "get": {
        "summary": "Returns a vendor based on a single ID",
        "operationId": "findVendorById",
        "tags": [
          "vendor"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of vendor to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Vendor response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/vendor"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/account-entries": {
      "get": {
        "summary": "Returns all dollar credits and debits from the system that the user has access to",
        "description": "Results are ordered by increasing settled dates, falling back to IDs when multiple entries settled on the same day.",
        "operationId": "findAccountEntries",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "date-after",
            "in": "query",
            "description": "Only return entries with dates after this date (inclusive).",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "date-before",
            "in": "query",
            "description": "Only return entries with dates before this date (exclusive).",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "balance",
            "in": "query",
            "description": "Add the `balance` property to returned entries.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "reason",
            "in": "query",
            "description": "The reason slugs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "affiliate-referral"
                ]
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Account entry response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/accountEntry"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/account-entry/{id}": {
      "get": {
        "summary": "Returns a dollar credit or debit based on a single ID",
        "operationId": "findAccountEntryById",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of account entry to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Account entry response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountEntry"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/payments": {
      "post": {
        "summary": "Create a new payment (settled immediately)",
        "operationId": "addPayment",
        "tags": [
          "payment"
        ],
        "responses": {
          "200": {
            "description": "Account entry response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountEntry"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/payment"
              }
            }
          },
          "description": "Payment to create. Amount and payment-method are both required.",
          "required": true
        }
      }
    },
    "/payment-methods": {
      "get": {
        "summary": "Returns all payment methods from the system that the user has access to",
        "description": "Methods associated with a person are ordered by decreasing preference. The ordering between methods associated with different people is undefined.",
        "operationId": "findPayments",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "Only return (in)active payment methods.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Payment method response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/paymentMethod"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new payment method",
        "operationId": "addPaymentMethod",
        "tags": [
          "payment"
        ],
        "responses": {
          "200": {
            "description": "Payment method response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/paymentMethod"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/newPaymentMethod"
              }
            }
          },
          "description": "Payment method to add.",
          "required": true
        }
      }
    },
    "/payment-method/{id}": {
      "get": {
        "summary": "Returns a payment method based on a single ID",
        "operationId": "findPaymentMethodById",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of payment method to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Payment method response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/paymentMethod"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "summary": "Deactivates a payment method based on a single ID",
        "operationId": "deactivatePaymentMethodById",
        "tags": [
          "payment"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of payment method to deactivate.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deactivate successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/rewards": {
      "get": {
        "summary": "Returns all reward credits and debits from the system that the user has access to",
        "description": "Results are ordered by increasing settled times, falling back to ID for pending debits.",
        "operationId": "findRewards",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "date-after",
            "in": "query",
            "description": "Only return entries with dates after this date (inclusive).",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "date-before",
            "in": "query",
            "description": "Only return entries with dates before this date (exclusive).",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Reward status to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "pending",
                  "settled"
                ]
              }
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "totals",
            "in": "query",
            "description": "Add the `total-credit`, `total-debit`, and `total-pending` properties to returned entries.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Reward response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/reward"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/reward/{id}": {
      "get": {
        "summary": "Returns a reward credit or debit based on a single ID",
        "operationId": "findRewardById",
        "tags": [
          "account"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of reward to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Reward response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/reward"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/addresses": {
      "get": {
        "summary": "Returns all addresses from the system that the user has access to",
        "description": "Addresses associated with a person are ordered by decreasing preference. The ordering between addresses associated with different people or (for the same person) with the same preference value is undefined.",
        "operationId": "findAddresses",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"country\", \"person\", and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Address response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/address"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new address",
        "operationId": "addAddress",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"country\", \"person\", and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Address response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/address"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/address"
              }
            }
          },
          "description": "Address to add.",
          "required": true
        }
      }
    },
    "/address/{id}": {
      "get": {
        "summary": "Returns a address based on a single ID",
        "operationId": "findAddressById",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of address to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"country\", \"person\", and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Address response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/address"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing address",
        "operationId": "updateAddress",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of address to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"country\", \"person\", and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Address response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/address"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/address"
              }
            }
          },
          "description": "Address to update.",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing address",
        "operationId": "deleteAddress",
        "tags": [
          "address"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of address to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/countries": {
      "get": {
        "summary": "Returns all countries from the system",
        "description": "Countries that are allowed to be used with addresses, ordered by name.",
        "operationId": "findCountries",
        "tags": [
          "country"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Country response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/country"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/regions": {
      "get": {
        "summary": "Returns all country regions from the system",
        "description": "Regions that are allowed to be used with addresses in the United States and Canada, ordered alphabetically. Other countries may use any string values for their regions.",
        "operationId": "findRegions",
        "tags": [
          "region"
        ],
        "parameters": [
          {
            "name": "country",
            "in": "query",
            "description": "Country to filter by.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Country region response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/region"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/emails": {
      "get": {
        "summary": "Returns all emails from the system that the user has access to.",
        "description": "Emails associated with a person are ordered by decreasing preference. The ordering between emails associated with different people or (for the same person) with the same preference value is undefined.",
        "operationId": "findEmails",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/email"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new email",
        "operationId": "addEmail",
        "tags": [
          "email"
        ],
        "responses": {
          "200": {
            "description": "Email response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/email"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateEmailUserPassword"
              }
            }
          },
          "description": "Email to add.",
          "required": true
        }
      }
    },
    "/email/{id}": {
      "get": {
        "summary": "Returns a email based on a single ID",
        "operationId": "findEmailById",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of email to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/email"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing email",
        "operationId": "updateEmail",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of email to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Email response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/email"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateEmailUserPassword"
              }
            }
          },
          "description": "Email to update.",
          "required": true
        }
      },
      "delete": {
        "summary": "Delete an existing email",
        "operationId": "deleteEmail",
        "tags": [
          "email"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of email to delete.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/people": {
      "get": {
        "summary": "Returns all people from the system that the user has access to",
        "operationId": "findPeople",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "drop",
            "in": "query",
            "description": "Drop IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include additional information. Currently supports \"email\" as described in the email model, \"order-place-issue\", and \"is-drop-coordinator\".",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "customerTypes",
            "in": "query",
            "description": "Customer types of the customers.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Person response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/person"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/people/actions/find-affiliate-code-by-marketing-slug/{marketing-slug}": {
      "get": {
        "summary": "Returns an affiliate code based on a marketing slug (no authorization required)",
        "operationId": "findAffiliateCodeByMarketingSlug",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "marketing-slug",
            "in": "path",
            "description": "Marketing slug of affiliate code to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Affiliate code response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/affiliateCode"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/person/{id}": {
      "get": {
        "summary": "Returns a person based on a single ID, if the user has access to the person",
        "operationId": "findPersonById",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of person to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include additional information. Currently supports \"email\" as described in the email model, \"order-place-issue\", and \"is-drop-coordinator\".",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Person response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/person"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update an existing person",
        "operationId": "updatePerson",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of person to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Person response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/person"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "$ref": "#/components/requestBodies/updatePersonUserPassword"
        }
      }
    },
    "/person": {
      "get": {
        "summary": "Returns the authenticated person (yourself)",
        "operationId": "findPersonByAuth",
        "tags": [
          "person"
        ],
        "parameters": [
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include additional information. Currently supports \"email\" as described in the email model and \"order-place-issue\".",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Person response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/person"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update the authenticated person (yourself)",
        "operationId": "updatePersonByAuth",
        "tags": [
          "person"
        ],
        "responses": {
          "200": {
            "description": "Person response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/person"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "$ref": "#/components/requestBodies/updatePersonUserPassword"
        }
      }
    },
    "/person/{id}/ordered-packaged-products": {
      "get": {
        "summary": "Returns aggregated information about packaged products ordered by the given customer within the last two years",
        "operationId": "listOrderedPackagedProducts",
        "tags": [
          "person",
          "product"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the person whose ordered packaged products should be fetched.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The ordered packaged products response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/orderedPackagedProduct"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/session": {
      "get": {
        "summary": "Returns information about the current cookie-based session",
        "operationId": "findSessionByAuth",
        "tags": [
          "session"
        ],
        "security": [
          {
            "sessionCookie": []
          }
        ],
        "responses": {
          "200": {
            "description": "Session response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/session"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/login": {
      "post": {
        "summary": "Authenticate and receive a session cookie",
        "operationId": "login",
        "tags": [
          "session"
        ],
        "responses": {
          "200": {
            "description": "Session response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/session"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/usernamePassword"
                  },
                  {
                    "$ref": "#/components/schemas/token"
                  }
                ]
              }
            }
          }
        }
      }
    },
    "/logout": {
      "post": {
        "summary": "Clears the current cookie-based session",
        "operationId": "logout",
        "tags": [
          "session"
        ],
        "security": [
          {
            "sessionCookie": []
          }
        ],
        "responses": {
          "200": {
            "description": "Session response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/session"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/registration/register": {
      "post": {
        "summary": "Register a new person",
        "description": "When the user provides an email address, check for existing accounts which use that email address.\n\n* If an inactive account using the email address is found, send an inactive-member email pointing the user at customer service. Do not authenticate the user.\n\n* If an active account using the email address is found, send an active-member email with an authenticating URL with an authentication token. Following that URL will (possibly indirectly) send the token to this API's login endpoint to authenticate the bearer.\n\n* If no account using that email address is found, create a new account and immediately authenticate the user. If they provided an email address or SMS number, potentially send a welcome-aboard notification.",
        "operationId": "registerPerson",
        "tags": [
          "registration"
        ],
        "parameters": [
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"session.person\" and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Registration request response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/registrationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/registrationRequest"
              }
            }
          },
          "required": true
        }
      }
    },
    "/registration/resend": {
      "post": {
        "summary": "Resend the registration notification to the user",
        "operationId": "resendRegistrationNotification",
        "tags": [
          "registration"
        ],
        "responses": {
          "204": {
            "description": "Registration email re-sent.",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/resendRegistrationNotification"
              }
            }
          },
          "required": true
        }
      }
    },
    "/password/reset": {
      "post": {
        "summary": "Initiate a password reset, to be completed by a call to /password/confirm",
        "operationId": "resetPasswordRequest",
        "tags": [
          "password"
        ],
        "responses": {
          "204": {
            "description": "Password-reset email sent (if the registration email corresponded to an existing person. Otherwise, you'll still get a 204 to avoid leaking information about member email addresses)."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/passwordResetRequest"
              }
            }
          },
          "required": true
        }
      }
    },
    "/password/confirm": {
      "post": {
        "summary": "Complete an in-progress password reset",
        "operationId": "passwordResetConfirmation",
        "tags": [
          "password"
        ],
        "responses": {
          "200": {
            "description": "Person response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/person"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/passwordResetConfirmation"
              }
            }
          },
          "description": "The registrant's confirmation token.",
          "required": true
        }
      }
    },
    "/notifications": {
      "get": {
        "summary": "Returns all notifications from the system that the user has access to",
        "operationId": "findNotifications",
        "tags": [
          "notification"
        ],
        "parameters": [
          {
            "name": "active",
            "in": "query",
            "description": "Only return (in)active notifications.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "annotate-person",
            "in": "query",
            "description": "Add a boolean dismissed field to the results with whether or not the annotate-person has dismissed this notification, required with dismissed.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "dismissed",
            "in": "query",
            "description": "Only return notifications that are (not) dismissed by the annotate-person.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Notification response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/notification"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/notification-dismissals": {
      "post": {
        "summary": "Create a notification dismissal (a user may only dismiss notifications for himself)",
        "operationId": "addNotificationDismissal",
        "tags": [
          "notification"
        ],
        "responses": {
          "200": {
            "description": "Notification dismissal response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/notificationDismissal"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/notificationDismissal"
              }
            }
          },
          "description": "Notification dismissal to add.",
          "required": true
        }
      }
    },
    "/favorites": {
      "get": {
        "summary": "Returns a list of all customer's packaged product favorites",
        "operationId": "findFavorites",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "filter-person",
            "in": "query",
            "description": "Person IDs to filter by.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "name": "active",
            "in": "query",
            "description": "Only return favorites associated with (in)active packaged products. For example, we sometimes discontinue products and then pick them back up later. In this context, \"active\" means \"for sale to at least some customers\".",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"packaged-product\" and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Array of favorites response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/favorite"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Creates and returns a customer favorite",
        "operationId": "addFavorite",
        "tags": [
          "favorite"
        ],
        "responses": {
          "200": {
            "description": "Favorite response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/favorite"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateFavorite"
              }
            }
          },
          "description": "Favorite to create.",
          "required": true
        }
      }
    },
    "/favorite/{id}": {
      "get": {
        "summary": "Returns a single customer favorite",
        "operationId": "findFavoriteById",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of favorite to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"packaged-product\" and descendants.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Favorite response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/favorite"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Updates and returns a customer favorite",
        "operationId": "updateFavorite",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of favorite to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Favorite response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/favorite"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/updateFavorite"
              }
            }
          },
          "description": "Favorite to update.",
          "required": true
        }
      },
      "delete": {
        "summary": "Deletes a customer favorite",
        "operationId": "deleteFavorite",
        "tags": [
          "favorite"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of favorite to update.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successful."
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/printers": {
      "get": {
        "summary": "Returns all printers from the system that the user has access to",
        "operationId": "findPrinters",
        "tags": [
          "printer"
        ],
        "parameters": [
          {
            "name": "delivery",
            "in": "query",
            "description": "Printer delivery method.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "http",
                  "cups",
                  "bartender"
                ]
              }
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Printer format.",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "pdf",
                  "epl2",
                  "bartender"
                ]
              }
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Printer response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/printer"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/printer/{id}": {
      "get": {
        "summary": "Returns a printer based on a single ID, if the user has access to it",
        "operationId": "findPrinterById",
        "tags": [
          "printer"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of printer to fetch.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Printer response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/printer"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/warehouses": {
      "get": {
        "summary": "Returns all warehouses from the system that the user has access to",
        "operationId": "findWarehouses",
        "tags": [
          "warehouse"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of results to return.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "start",
            "in": "query",
            "description": "Offset to the first result to return. Use negative numbers to offset from the end of the result list.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Warehouse response.",
            "headers": {
              "Count": {
                "description": "Total number of matching results (how many you'd get if you could set an infinite `limit`).",
                "schema": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/warehouse"
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/warehouse/{code}": {
      "get": {
        "summary": "Returns a warehouse based on a single code, if the user has access to it",
        "operationId": "findWarehouseByCode",
        "tags": [
          "warehouse"
        ],
        "parameters": [
          {
            "name": "code",
            "in": "path",
            "description": "Code of warehouse to fetch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Warehouse response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/warehouse"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/ip2location": {
      "get": {
        "summary": "Returns location data for the requesting ip address",
        "operationId": "ip2Location",
        "parameters": [
          {
            "name": "inline",
            "in": "query",
            "description": "For convenience, include a full representation of the inlined property. Currently supports \"address.country\".",
            "required": false,
            "style": "form",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Ip2location response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ip2location"
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/order-frequency-segment": {
      "get": {
        "summary": "Get a customer order frequency",
        "description": "Returns 'active' if the customer has ordered within the last 120 days, 'activeag' (for \"active aging\") if they've ordered before but not within 120 days, `activereg` if they've never ordered. If no customer exists, returns `new`.",
        "operationId": "orderFrequencySegment",
        "parameters": [
          {
            "name": "email",
            "in": "query",
            "description": "Email of the person to look up.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns 'active' if the customer has ordered within the last 120 days, 'activeag' (for \"active aging\") if they've ordered before but not within 120 days, `activereg` if they've never ordered. If no customer exists, returns `new`.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "email": {
                      "description": "Email address sent for the lookup.",
                      "type": "string"
                    },
                    "orderFrequencySegment": {
                      "type": "string",
                      "enum": [
                        "new",
                        "active",
                        "activeag",
                        "activereg"
                      ]
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "Unexpected error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error"
                }
              }
            }
          }
        }
      }
    },
    "/drops/actions/convert-route": {
      "post": {
        "summary": "Move drop(s) to a different route",
        "operationId": "post-drops-actions-convert-route",
        "parameters": [],
        "description": "Move one or more drops from one route to another.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "sourceRouteId": {
                    "type": "integer",
                    "description": "The ID of the route that the drop(s) are currently on."
                  },
                  "targetRouteId": {
                    "type": "integer",
                    "description": "The ID of the route that the drop(s) should be moved to."
                  },
                  "dropIds": {
                    "type": "array",
                    "description": "The IDs of drops to be moved.",
                    "items": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/mail/trip/{tripId}": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "tripId",
          "in": "path",
          "required": true,
          "description": ""
        }
      ],
      "post": {
        "summary": "Email drops on a trip",
        "operationId": "post-mail-trip-tripId",
        "responses": {
          "200": {
            "description": "OK"
          }
        },
        "description": "Sends one or more emails to the drop coordinators (and customers, optionally) of one or more drops on a specific trip.\n\nNotes: \n- This requires that the trip not have a status of `future`.",
        "parameters": [
          {
            "$ref": "#/components/parameters/mailCustomers"
          },
          {
            "$ref": "#/components/parameters/mailDrop"
          },
          {
            "$ref": "#/components/parameters/mailMessage"
          },
          {
            "$ref": "#/components/parameters/mailSubject"
          },
          {
            "$ref": "#/components/parameters/mailTarget"
          }
        ]
      }
    },
    "/mail/route/{routeName}": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "routeName",
          "in": "path",
          "required": true
        }
      ],
      "post": {
        "summary": "Email drops on a route",
        "operationId": "post-mail-route-routeName",
        "responses": {
          "200": {
            "description": "OK"
          }
        },
        "description": "Sends one or more emails to the drop coordinators (and members, optionally) of one or more drops on a specific route.",
        "parameters": [
          {
            "$ref": "#/components/parameters/mailCustomers"
          },
          {
            "$ref": "#/components/parameters/mailDrop"
          },
          {
            "$ref": "#/components/parameters/mailMessage"
          },
          {
            "$ref": "#/components/parameters/mailSubject"
          },
          {
            "$ref": "#/components/parameters/mailTarget"
          }
        ]
      }
    }
  },
  "servers": [
    {
      "url": "https://api.azurestandard.com"
    }
  ],
  "components": {
    "requestBodies": {
      "updatePersonUserPassword": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/updatePersonUserPassword"
            }
          }
        },
        "description": "Person to update.",
        "required": true
      }
    },
    "securitySchemes": {
      "basic": {
        "type": "http",
        "description": "Basic authentication (http://tools.ietf.org/html/rfc2617#section-2).",
        "scheme": "basic"
      },
      "sessionCookie": {
        "type": "apiKey",
        "in": "header",
        "name": "cookie",
        "description": "Session cookie (http://tools.ietf.org/html/rfc6265)."
      }
    },
    "parameters": {
      "orderInline": {
        "name": "inline",
        "in": "query",
        "description": "Optional properties returned if specified in the request.",
        "style": "form",
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "dropMembershipId",
              "customer"
            ]
          }
        }
      },
      "stopInline": {
        "name": "inline",
        "in": "query",
        "description": "Optional properties returned if specified in the request.",
        "required": false,
        "style": "form",
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "drop",
              "pickup",
              "truckload"
            ]
          }
        }
      },
      "mailCustomers": {
        "schema": {
          "type": "boolean"
        },
        "in": "query",
        "name": "customers",
        "description": "By default, an email is sent to the coordinator(s) of each drop. If this is `true`, the email is also sent to the customers of each drop."
      },
      "mailDrop": {
        "schema": {
          "type": "array",
          "items": {
            "type": "int"
          }
        },
        "in": "query",
        "name": "drop",
        "description": "The dropIds of the drops that should receive the email."
      },
      "mailMessage": {
        "schema": {
          "type": "string"
        },
        "in": "query",
        "name": "message",
        "description": "The email's content."
      },
      "mailSubject": {
        "schema": {
          "type": "string"
        },
        "in": "query",
        "name": "subject",
        "description": "The email's subject."
      },
      "mailTarget": {
        "schema": {
          "type": "string"
        },
        "in": "query",
        "name": "target",
        "description": "The email addresses to send the *test* message to (for previewing). Including this parameter will prevent the email from being sent to the intended recipients (its intended use is for sending previews)."
      },
      "packagedProductInline": {
        "name": "inline",
        "in": "query",
        "description": "For convenience, include a full representation of the inlined property.",
        "required": false,
        "style": "form",
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "favorites",
              "next-purchase-arrival",
              "quantity-on-next-purchase",
              "product",
              "vendors"
            ]
          }
        }
      }
    },
    "schemas": {
      "affiliateCode": {
        "description": "An affiliate code and associated marketing slug of a person.",
        "type": "object",
        "properties": {
          "marketing-slug": {
            "description": "Unique marketing slug of a person.",
            "type": "string"
          },
          "affiliate-code": {
            "description": "Unique affiliate code of the same person.",
            "type": "string"
          }
        },
        "required": [
          "marketing-slug",
          "affiliate-code"
        ]
      },
      "affiliateReferral": {
        "description": "An affiliate referral.",
        "type": "object",
        "properties": {
          "referred": {
            "description": "Date-time the referred person's account was referred.",
            "type": "string",
            "format": "date-time"
          },
          "name": {
            "description": "Name of the person referred.",
            "type": "string"
          },
          "amount-earned": {
            "description": "Dollar value for the sum of account credits to the referrer that were caused by this referral.",
            "type": "number",
            "format": "float"
          }
        },
        "required": [
          "referred",
          "name",
          "amount-earned"
        ]
      },
      "bartenderHost": {
        "description": "A BarTender host/instance.",
        "type": "object",
        "properties": {
          "code": {
            "description": "Slug for stable reference (e.g. \"bt1\").",
            "type": "string"
          },
          "name": {
            "description": "Human readable name (e.g. \"Bar Tender 1\").",
            "type": "string"
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "bartenderTemplate": {
        "description": "A BarTender template/document.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "path": {
            "description": "Path to the BarTender template on the BarTender host filesystem.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "path"
        ]
      },
      "bartenderPrintConfiguration": {
        "description": "A BarTender print configuration for BarTender print requests. These configurations are added to warehouse pieces (which are related to individual stock) in Beehive and are used to route print requests and to tell BarTender which template should be used. A print request will be created for each print configuration associated with a stock location's warehouse.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "host": {
            "description": "The BarTender host's code.",
            "type": "string"
          },
          "printer": {
            "description": "The printer ID. The referenced printer must support the `bartender` format and delivery methods.",
            "type": "integer",
            "format": "int64"
          },
          "template": {
            "description": "The BarTender template ID.",
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "id",
          "host",
          "printer",
          "template"
        ]
      },
      "companyDirectoryEntry": {
        "description": "A company directory entry.",
        "type": "object",
        "properties": {
          "full-name": {
            "type": "string"
          },
          "first-name": {
            "type": "string"
          },
          "last-name": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "department": {
            "$ref": "#/components/schemas/department"
          },
          "office": {
            "type": "string"
          },
          "phone-number": {
            "type": "string"
          },
          "phone-ext": {
            "type": "string"
          },
          "mobile": {
            "type": "string"
          },
          "country": {
            "type": "string"
          },
          "city": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "zip": {
            "type": "string"
          },
          "street": {
            "type": "string"
          }
        }
      },
      "department": {
        "description": "An Azure department.",
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the department.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "report": {
        "description": "A report.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "The name of the report.",
            "type": "string"
          },
          "category": {
            "description": "The ID of the report category the report is in.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "reportCategory": {
        "description": "A report category.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "The category name.",
            "type": "string"
          },
          "customer-pricing": {
            "description": "Whether or not reports in this category are customer pricing groups (for use in the pricing module).",
            "type": "boolean"
          }
        },
        "required": [
          "id",
          "name",
          "customer-pricing"
        ]
      },
      "drop": {
        "description": "An order-delivery location.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "coordinators": {
            "description": "Coordinators for this drop. The first entry is the primary contact.",
            "type": "array",
            "items": {
              "description": "Person ID for this coordinator.",
              "type": "integer",
              "format": "int32"
            }
          },
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "geo": {
            "$ref": "#/components/schemas/geo"
          },
          "active": {
            "description": "Whether or not this drop is actively ordering.",
            "type": "boolean"
          },
          "accounts-payable-contact": {
            "description": "Name of the drop employee Azure's accounts-payable should contact, if different from the primary contact.",
            "type": "string"
          },
          "after-hours-phone": {
            "description": "E.123 telephone number Azure should call if we need to contact the drop after business hours.",
            "type": "string"
          },
          "business-hours": {
            "description": "Regular business hours for the drop (e.g. \"8:30-6 Mon-Fri, 9-5 Sat, closed Sun\").",
            "type": "string"
          },
          "business-type": {
            "description": "What type of business do you run?.",
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "clinics-practitioner",
                "manufacturing-business",
                "online-store",
                "restaurant",
                "retail-store",
                "seasonal",
                "wholesale-distributor"
              ]
            }
          },
          "buyer": {
            "description": "Name of the drop employee who usually places orders for this drop, if different from the primary contact.",
            "type": "string"
          },
          "pickup-contact": {
            "description": "Do customers need to contact you to pick up their orders?  Retail preference. Only available when how-members-receive is \"can-hold-sometimes\" or \"can-hold\".",
            "type": "string",
            "enum": [
              "yes",
              "no",
              "first-time-only"
            ]
          },
          "contact-person": {
            "type": "string"
          },
          "contact-type": {
            "description": "How can customers contact you?.",
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "phone",
                "email",
                "other"
              ]
            }
          },
          "contact-type-other-notes": {
            "description": "Description of the alternative contact method. Available when contact-type includes \"other\".",
            "type": "string"
          },
          "contact-type-phone": {
            "description": "E.123 telephone number customers should call to contact this drop. Available when contact-type includes \"phone\".",
            "type": "string"
          },
          "directions": {
            "description": "Driving directions for a truck approaching this drop (e.g. avoiding low bridges, tight turns, etc. on more obvious routes).",
            "type": "string"
          },
          "driver-callable-phone": {
            "description": "E.123 telephone number for a driver approaching this drop.",
            "type": "string"
          },
          "exclusivity": {
            "type": "string",
            "enum": [
              "open",
              "semi-open",
              "closed"
            ]
          },
          "food-stamps": {
            "description": "Does your drop accept food stamps?  Business preference.",
            "type": "string",
            "enum": [
              "yes",
              "no",
              "limited"
            ]
          },
          "food-stamps-limited-notes": {
            "description": "Description of limited food-stamp acceptance. Business preference. Only available when food-stamps is \"limited\".",
            "type": "string"
          },
          "hold-time": {
            "description": "How long will you hold a customer's order?  For example, \"24 hours\", \"three days for dry, frozen by arrangement\", etc. Retail preference. Only available when how-members-receive is \"can-hold-sometimes\" or \"can-hold\".",
            "type": "string"
          },
          "how-members-receive": {
            "description": "How do your members receive their items?  Retail preference.",
            "type": "string",
            "enum": [
              "must-show",
              "can-hold-sometimes",
              "can-hold"
            ]
          },
          "invoice-always": {
            "description": "Always print paper invoices, regardless of the customer's invoice-delivery preference.",
            "type": "boolean"
          },
          "okay-to-text-phone": {
            "description": "Can the driver send text messages to the driver-callable phone?.",
            "type": "boolean"
          },
          "parking": {
            "description": "Parking location ownership for this drop.",
            "type": "string",
            "enum": [
              "home",
              "business",
              "non-profit",
              "public",
              "other-building"
            ]
          },
          "special-orders": {
            "description": "Do you take special orders for Azure products from customers? Wholesale preference.",
            "type": "boolean"
          },
          "storage": {
            "description": "Storage environments available at this drop.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/storage"
            }
          },
          "fees": {
            "$ref": "#/components/schemas/dropFees"
          },
          "order-minimum": {
            "description": "The minimum total order value (in dollars) required to ship a particular trip to this drop. For example, if the minimum is $400 and there are three $100 orders placed for a stop, that stop will be under-minimum, and the orders will not be shipped. If, on the other hand, there were four $100 orders placed for a stop, that stop would be (just) over-minimum, and the orders would be shipped.",
            "type": "number",
            "format": "float"
          },
          "members": {
            "description": "Number of customers on this drop.",
            "type": "integer",
            "format": "int32"
          },
          "order-frequency": {
            "description": "Order counts for this drop over the past year.",
            "type": "object",
            "properties": {
              "orders": {
                "description": "Count of orders for this route-trip-drop.",
                "type": "integer",
                "format": "int32"
              },
              "cutoff": {
                "description": "Cutoff date for this route-trip.",
                "type": "string",
                "format": "date"
              }
            }
          },
          "notes": {
            "description": "Free-form Markdown notes for any member-oriented drop information that doesn't fit into an existing field. This information is public for open and semi-open drops, and visible to all members for closed drops.",
            "type": "string"
          },
          "sells-finished-goods-to-azure": {
            "description": "Do you also sell your finished good to Azure?  Only available if business-type includes \"manufacturing-business\".",
            "type": "boolean"
          },
          "uses-azure-to-drop-ship": {
            "description": "Do you drop ship Azure orders (have Azure ship directly to your customers)?  Only available if business-type includes \"online-store\".",
            "type": "boolean"
          },
          "timezone": {
            "type": "string",
            "description": "The drop's timezone (e.g. America/Los_Angeles)."
          }
        },
        "required": [
          "id",
          "name",
          "geo",
          "active",
          "exclusivity",
          "members",
          "timezone"
        ]
      },
      "newDrop": {
        "$ref": "#/components/schemas/drop"
      },
      "updateDrop": {
        "description": "An order-delivery location.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "geo": {
            "$ref": "#/components/schemas/geo"
          },
          "active": {
            "description": "Whether or not this drop is actively ordering.",
            "type": "boolean"
          },
          "parking": {
            "description": "Parking location ownership for this drop.",
            "type": "string",
            "enum": [
              "home",
              "business",
              "non-profit",
              "public"
            ]
          },
          "storage": {
            "description": "Storage environments available at this drop.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/storage"
            }
          },
          "fees": {
            "$ref": "#/components/schemas/dropFees"
          },
          "notes": {
            "description": "Free-form Markdown notes for any member-oriented drop information that doesn't fit into an existing field. This information is public for open and semi-open drops, and visible to all members for closed drops.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "active"
        ]
      },
      "dropFees": {
        "description": "Additional costs for members receiving at a drop.",
        "type": "object",
        "properties": {
          "medium": {
            "description": "Payment medium (nothing, volunteer time, or a monetary payment).",
            "type": "string",
            "enum": [
              "volunteer",
              "payment"
            ]
          },
          "condition": {
            "description": "Fee trigger (never, only when orders are held, or for every order).",
            "type": "string",
            "enum": [
              "held",
              "order"
            ]
          },
          "notes": {
            "description": "Fee amount and structure.",
            "type": "string"
          }
        }
      },
      "dropMembership": {
        "description": "A drop membership.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "customer": {
            "description": "Customer that has the drop membership.",
            "type": "integer",
            "format": "int64"
          },
          "drop": {
            "description": "The drop this membership is for.",
            "type": "integer",
            "format": "int64"
          },
          "active": {
            "description": "Whether or not this membership is active. Pending memberships are active, and the usual flow for semi-open drops is (active true, pending true) -> (active true, pending false) -> (active false, pending false).",
            "type": "boolean"
          },
          "pending": {
            "description": "Whether the membership is pending (true) or accepted (false).",
            "type": "boolean"
          },
          "created": {
            "description": "Date-time the drop-membership was created.",
            "type": "string",
            "format": "date-time"
          },
          "heavy": {
            "description": "Whether the member can get pallets, totes, barrels, and other heavy objects off a truck (defaults to false).",
            "type": "boolean"
          },
          "notifications": {
            "$ref": "#/components/schemas/dropMembershipNotifications"
          },
          "gratitude-total": {
            "description": "Total \"Azure Gratitude\" (monetary incentive for hosting a drop) received from being this drop's coordinator. Only set if the \"inline\" query parameter contains \"gratitude-total\".",
            "type": "number",
            "format": "float",
            "minimum": 0
          },
          "computed": {
            "description": "Optional computed properties included via the \"computed\" parameter.",
            "type": "object",
            "properties": {
              "lastOrderPlaced": {
                "description": "Date-time the member last placed an order on this drop.",
                "type": "string",
                "format": "date-time"
              }
            }
          }
        },
        "required": [
          "id",
          "customer",
          "drop",
          "active",
          "pending",
          "created",
          "notifications"
        ]
      },
      "updateDropMembership": {
        "description": "A drop membership to update.",
        "type": "object",
        "properties": {
          "customer": {
            "description": "Customer that has the drop membership.",
            "type": "integer",
            "format": "int64"
          },
          "drop": {
            "description": "The drop this membership is for.",
            "type": "integer",
            "format": "int64"
          },
          "active": {
            "description": "Whether or not this membership is active.",
            "type": "boolean"
          },
          "pending": {
            "description": "Whether the membership is pending (true) or accepted (false).",
            "type": "boolean"
          },
          "heavy": {
            "description": "Whether the member can get pallets, totes, barrels, and other heavy objects off a truck (defaults to false).",
            "type": "boolean"
          },
          "notifications": {
            "$ref": "#/components/schemas/dropMembershipNotifications"
          }
        },
        "required": [
          "customer",
          "drop",
          "active"
        ]
      },
      "newDropMembership": {
        "$ref": "#/components/schemas/updateDropMembership"
      },
      "dropMembershipNotifications": {
        "description": "Configure if and how a user receives per-drop notifications.",
        "type": "object",
        "properties": {
          "cutoff": {
            "description": "Receive notifications from Azure before cutoffs for this drop.",
            "format": "array",
            "items": {
              "$ref": "#/components/schemas/notificationChannel"
            }
          }
        }
      },
      "file": {
        "description": "An opaque file. This is usually used for product and category images, but could also be used for other content.",
        "type": "object",
        "properties": {
          "id": {
            "description": "The identifier for this file. This is generated by the server, but will be a UUID as defined by RFC 4122.",
            "type": "string"
          }
        },
        "required": [
          "id"
        ]
      },
      "pickup": {
        "description": "A purchase-pickup location.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "vendors": {
            "description": "Vendors supplying this pickup.",
            "type": "array",
            "items": {
              "description": "Vendor ID.",
              "type": "integer",
              "format": "int32"
            }
          },
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "geo": {
            "$ref": "#/components/schemas/geo"
          },
          "active": {
            "description": "Whether or not this pickup is actively supplying purchases.",
            "type": "boolean"
          },
          "notes": {
            "description": "Free-form Markdown notes for any pickup information that doesn't fit into an existing field.",
            "type": "string"
          },
          "timezone": {
            "type": "string",
            "description": "The pickup's timezone (e.g. America/Los_Angeles)."
          }
        },
        "required": [
          "id",
          "name",
          "vendors",
          "address",
          "geo",
          "active",
          "timezone"
        ]
      },
      "route": {
        "description": "An order-delivery truck route.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "cutoff-frequency": {
            "description": "Number of days between cutoffs.",
            "type": "integer",
            "format": "int32"
          },
          "delivery-offset": {
            "description": "Number of days after cutoff before the first stop.",
            "type": "integer",
            "format": "int32"
          },
          "internal": {
            "description": "Is the route for internal use? This controls whether customers can access the route via the API (they can't if this is `true`).",
            "type": "boolean"
          },
          "backhaul-cost-per-pound": {
            "description": "Route backhaul cost per pound.",
            "type": "number",
            "format": "float"
          },
          "backhaul-cost-per-pickup": {
            "description": "Route backhaul cost per pickup.",
            "type": "number",
            "format": "float"
          },
          "hub": {
            "description": "A hub route is one that occurs after we ship an entire route to a distribution hub (such as a big loading dock in Kansas City). The route is unloaded at the hub and reloaded onto another carrier's truck for actual delivery. \n\nIn terms of Customer Care, it is a one-way route; the truck, trailer, and any shipped goods refused by a customer never return to the warehouse.",
            "type": "boolean"
          },
          "driverName": {
            "description": "Truck driver's name.",
            "type": "string"
          },
          "driverPhone": {
            "description": "Truck driver's phone.",
            "type": "string"
          },
          "notes": {
            "description": "General notes about the route.",
            "type": "string"
          },
          "isActive": {
            "type": "boolean"
          },
          "isDrivable": {
            "type": "boolean",
            "description": "This is `true` for most routes. Routes that are *not* drivable are essentially ones that use the route construct in ways contrary to the intended purpose of a route (e.g. the \"H\" (parcel carrier) route, will-call routes, the \"Glyphosate Free Living\" route, etc)."
          }
        },
        "required": [
          "name",
          "cutoff-frequency",
          "delivery-offset",
          "internal",
          "hub",
          "driverName",
          "driverPhone",
          "notes",
          "isActive",
          "isDrivable"
        ]
      },
      "updateRoute": {
        "description": "An order-delivery truck route's updated values.",
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "cutoff-frequency": {
            "description": "Number of days between cutoffs.",
            "type": "integer",
            "format": "int32"
          },
          "delivery-offset": {
            "description": "Number of days after cutoff before the first stop.",
            "type": "integer",
            "format": "int32"
          },
          "internal": {
            "description": "Is the route for internal use? This controls whether customers can access the route via the API (they can't if internal is true).",
            "type": "boolean"
          },
          "backhaul-cost-per-pound": {
            "description": "Route backhaul cost per pound.",
            "type": "number",
            "format": "float"
          },
          "backhaul-cost-per-pickup": {
            "description": "Route backhaul cost per pickup.",
            "type": "number",
            "format": "float"
          },
          "hub": {
            "description": "A hub route is a delivery route that occurs after we ship an entire route to a distribution hub (such as a big loading dock in Kansas City). The route is unloaded at the hub and reloaded onto another carrier's truck for actual delivery. In terms of Customer Care, It is a one-way route; the truck, trailer, and any shipped goods refused by a customer never return to the warehouse.",
            "type": "boolean"
          },
          "driverName": {
            "description": "Truck drivers name.",
            "type": "string"
          },
          "driverPhone": {
            "description": "Truck drivers phone.",
            "type": "string"
          },
          "notes": {
            "description": "General notes about the route.",
            "type": "string"
          }
        },
        "required": [
          "cutoff-frequency",
          "delivery-offset",
          "internal"
        ]
      },
      "newRoute": {
        "$ref": "#/components/schemas/route"
      },
      "trip": {
        "description": "A truck delivering orders along a route.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "route": {
            "description": "Name of the followed route.",
            "type": "string"
          },
          "cutoff": {
            "description": "Cutoff for placing orders on this trip.",
            "type": "string",
            "format": "date-time"
          },
          "confirmed": {
            "description": "When the trip was reviewed and orders were either accepted or (for short drops) bumped to the next trip. This will always be set before the trip is confirmed, and will be unset until then. Customer service and customers who have received a short-drop notification can continue to manipulate placed orders in the window between cutoff and confirmation.",
            "type": "string",
            "format": "date-time"
          },
          "pick-date": {
            "description": "Date-time that orders for this trip should be picked.",
            "type": "string",
            "format": "date-time"
          },
          "shipped": {
            "description": "Approximately when the truck left the warehouse. This will always be set after the truck has left, and will be unset until then.",
            "type": "string",
            "format": "date-time"
          },
          "delivery-start": {
            "description": "Estimated stop-time for the first stop.",
            "type": "string",
            "format": "date-time"
          },
          "delivery-end": {
            "description": "Estimated stop-time for the last stop.",
            "type": "string",
            "format": "date-time"
          },
          "backhaul-start": {
            "description": "Estimated date-time for the first backhaul.",
            "type": "string",
            "format": "date-time"
          },
          "backhaul-end": {
            "description": "Estimated date-time for the last backhaul.",
            "type": "string",
            "format": "date-time"
          },
          "warehouse-arrival": {
            "description": "Estimated date-time for warehouse arrival.",
            "type": "string",
            "format": "date-time"
          },
          "notes": {
            "description": "Free-form Markdown notes for additional trip information. We expect this will mostly be for delay causes (e.g. \"High winds in Laramie\" or \"The truck broke down\").",
            "type": "string"
          },
          "status": {
            "description": "Current stage of a trip's lifecycle.",
            "type": "string",
            "enum": [
              "new",
              "verified",
              "sequenced",
              "shipped"
            ]
          },
          "truckloads": {
            "type": "array",
            "description": "Array of truckloads (picksets). This will only be included if the `inline` query parameter includes `truckloads` and the trip is verified.",
            "items": {
              "$ref": "#/components/schemas/truckload"
            }
          }
        },
        "required": [
          "id",
          "route",
          "cutoff",
          "delivery-start"
        ]
      },
      "updateTrip": {
        "description": "A truck delivering orders along a route to be updated.",
        "type": "object",
        "properties": {
          "route": {
            "description": "Name of the followed route.",
            "type": "string"
          },
          "cutoff": {
            "description": "Cutoff for placing orders on this trip.",
            "type": "string",
            "format": "date-time"
          },
          "pick-date": {
            "description": "Date-time that orders for this trip should be picked.",
            "type": "string",
            "format": "date-time"
          },
          "delivery-start": {
            "description": "Estimated stop-time for the first stop.",
            "type": "string",
            "format": "date-time"
          },
          "delivery-end": {
            "description": "Estimated stop-time for the last stop.",
            "type": "string",
            "format": "date-time"
          },
          "backhaul-start": {
            "description": "Estimated date-time for the first backhaul.",
            "type": "string",
            "format": "date-time"
          },
          "backhaul-end": {
            "description": "Estimated date-time for the last backhaul.",
            "type": "string",
            "format": "date-time"
          },
          "warehouse-arrival": {
            "description": "Estimated date-time for warehouse arrival.",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "route",
          "cutoff",
          "delivery-start"
        ]
      },
      "updateTruckload": {
        "description": "A truckload to be updated.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "route-trip": {
            "description": "Route Trip id of truck.",
            "type": "int64"
          },
          "truck-number": {
            "description": "Truck Number of truck.",
            "type": "int32"
          },
          "truckDriverId": {
            "description": "Truck Driver id of truck.",
            "type": "int64"
          },
          "pick-date": {
            "description": "Date-time that orders for this truck should be picked.",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "id",
          "truckDriverId"
        ]
      },
      "routeStop": {
        "description": "A template used to create stops when a trip is created.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "route": {
            "description": "Route name for the route-stop.",
            "type": "string"
          },
          "drop": {
            "description": "Drop ID for the route-stop.",
            "type": "integer",
            "format": "int64"
          },
          "delivery-offset": {
            "description": "Offset from midnight on the morning of the trips's delivery start until the usual delivery time for this drop.",
            "type": "string",
            "format": "duration"
          },
          "drop-shipping-fee": {
            "$ref": "#/components/schemas/dropShippingFee"
          }
        },
        "required": [
          "id",
          "route",
          "drop",
          "delivery-offset"
        ]
      },
      "stop": {
        "description": "A trip stop or waypoint. Stops are created for all route-stops when a trip is created for that route. At confirmation time, stops that will not be visited (e.g. because they missed their order-minimum) are deleted. Stops are always either a drop or pickup.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "trip": {
            "description": "Trip ID for the stop.",
            "type": "integer",
            "format": "int64"
          },
          "dropId": {
            "description": "Always returned if the stop is a drop.",
            "type": "integer",
            "format": "int64"
          },
          "short-drop": {
            "description": "Whether short-drop warnings were sent out for this stop. If they were, customers can manipulate placed orders after cutoff time, although nobody can edit orders after the trip is confirmed.",
            "type": "boolean"
          },
          "pickupId": {
            "description": "Always returned if the stop is a pickup.",
            "type": "integer",
            "format": "int64"
          },
          "timezone": {
            "description": "IANA time zone location (https://www.iana.org/time-zones, e.g. America/Los_Angeles).",
            "type": "string"
          },
          "estimatedDelivery": {
            "description": "Editable until verification.",
            "type": "string",
            "format": "date-time"
          },
          "finalizedDelivery": {
            "description": "Editable between verification and delivery.",
            "type": "string",
            "format": "date-time"
          },
          "actualDelivery": {
            "description": "When the stop is actually reached.",
            "type": "string",
            "format": "date-time"
          },
          "drop-shipping-fee": {
            "$ref": "#/components/schemas/dropShippingFee"
          },
          "actualDeliveryBackdated": {
            "type": "boolean",
            "description": "The actual delivery was manually set to a datetime in the past."
          },
          "drop": {
            "description": "Only returned if the stop is a drop and the `inline` query parameter contains `drop`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/drop"
              }
            ]
          },
          "pickup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/pickup"
              }
            ],
            "description": "Only returned if the stop is a pickup and the `inline` query parameter contains `pickup`."
          },
          "truckload": {
            "description": "The truckload (pickset) with this stop's orders. This will only be included if the inline query parameter includes `truckload` and the trip is verified.",
            "allOf": [
              {
                "$ref": "#/components/schemas/truckload"
              }
            ]
          },
          "finalizedDeliveryFlag": {
            "oneOf": [
              {
                "enum": [
                  "driverWillCall",
                  "toBeDetermined",
                  "unknownDelay"
                ],
                "description": "This is used to indicate an exception-state for the finalized delivery. This is always returned if the trip's status is not `new`."
              }
            ],
            "type": "string"
          }
        },
        "required": [
          "id",
          "trip",
          "estimatedDelivery",
          "finalizedDelivery",
          "actualDeliveryBackdated"
        ]
      },
      "updateStop": {
        "description": "An update to a trip stop or waypoint.",
        "type": "object",
        "properties": {
          "trip": {
            "description": "Trip ID for the stop.",
            "type": "integer",
            "format": "int64"
          },
          "drop": {
            "description": "Drop ID for the stop.",
            "type": "integer",
            "format": "int64"
          },
          "pickup": {
            "description": "Pickup ID for the stop.",
            "type": "integer",
            "format": "int64"
          },
          "estimatedDelivery": {
            "description": "Editable until verification.",
            "type": "string",
            "format": "date-time"
          },
          "finalizedDelivery": {
            "description": "Editable between verification and delivery.",
            "type": "string",
            "format": "date-time"
          },
          "actualDelivery": {
            "description": "When the stop is actually reached.",
            "type": "string",
            "format": "date-time"
          },
          "actualDeliveryBackdated": {
            "type": "boolean",
            "description": "The actual delivery was manually set to a datetime in the past."
          }
        },
        "required": [
          "trip",
          "estimatedDelivery",
          "finalizedDelivery",
          "actualDeliveryBackdated"
        ]
      },
      "partiallyUpdateStop": {
        "description": "A partial update to a trip stop or waypoint.",
        "type": "object",
        "properties": {
          "estimatedDelivery": {
            "description": "Set or update the stop's estimated delivery datetime. This is editable until verification.",
            "type": "string",
            "format": "date-time"
          },
          "finalizedDelivery": {
            "description": "Set or update the stop's finalized delivery datetime. This is editable between verification and delivery.",
            "type": "string",
            "format": "date-time"
          },
          "actualDelivery": {
            "description": "Set or update the stop's actual delivery datetime. The API only allows this before the `deliveryEnd` of the stop's trip.",
            "type": "string",
            "format": "date-time"
          },
          "actualDeliveryBackdated": {
            "type": "boolean",
            "description": "Set or update whether the stop's actual delivery time was manually set to a datetime in the past."
          },
          "truckloadId": {
            "type": "integer",
            "format": "int64",
            "description": "Update the stop's truckload (pickset) by passing the ID of the truckload to change it to. This works regardless of whether the stop is a pickup or a drop."
          }
        }
      },
      "shippingService": {
        "description": "A parcel-carrier service. The listing below is ordered by carrier and then by increasing duration.",
        "type": "string",
        "enum": [
          "UPS 2nd Day Air",
          "UPS Ground",
          "USPS Priority Mail Express",
          "USPS Priority Mail"
        ]
      },
      "shippingClimate": {
        "description": "An environment for shipping products. 'all' is a shipping climate for products of all types. 'dry' includes both 'dry' and 'greenhouse' storage environments. 'chilled/frozen' includes both 'chilled' and 'frozen' storage environments.",
        "type": "string",
        "enum": [
          "all",
          "dry",
          "chilled/frozen"
        ]
      },
      "storage": {
        "description": "An environment for storing products. The related to shippingClimate is less detailed, because stock is generally in transit for less time than it is in storage.",
        "type": "string",
        "enum": [
          "dry",
          "chilled",
          "frozen",
          "greenhouse"
        ]
      },
      "packagedProduct": {
        "description": "A particular packaged form of a product.",
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          },
          "gtin13": {
            "description": "13-digit Global Trade Item Number (https://schema.org/gtin13).",
            "type": "string"
          },
          "size": {
            "description": "Size of the product (e.g. 12 oz., or 6x12 oz.).",
            "type": "string"
          },
          "packs": {
            "description": "Package organization (e.g. \"4\", \"4x32.5\", or \"2x4x32.5\").",
            "type": "string"
          },
          "unit": {
            "description": "Unit of measurement (\"ounce\", \"liter\", etc.).",
            "type": "string"
          },
          "weight": {
            "$ref": "#/components/schemas/weight"
          },
          "volume": {
            "description": "Volume of this packaged product in cubic feet.",
            "type": "number",
            "format": "float"
          },
          "price": {
            "$ref": "#/components/schemas/price"
          },
          "stock": {
            "description": "Amount of stock available for purchase. This includes breakdown ancestors. For example, if we have a single 4 x 6 x 14 oz case in the warehouse, the 4 x 6 x 14 oz packaging will have 1 stock, the 6 x 14 oz packaging will have 4 stock, and the 14 oz packaging will have 24 stock.",
            "type": "integer",
            "format": "int32"
          },
          "favorite": {
            "description": "If the annotate-person you associated with the request has favorited this packaged product.",
            "type": "boolean"
          },
          "favorites": {
            "description": "Number of people who've marked this packaged product as a favorite. This will only be included if the `inline` query parameter includes `favorites`.",
            "type": "integer",
            "format": "int32"
          },
          "tags": {
            "description": "Mark types for this packaged product.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "bargain-bin-notes": {
            "description": "Bargain-bin notes for this packaged product.",
            "type": "string"
          },
          "statusReason": {
            "description": "Reason this packaged product is in its current status.",
            "type": "string"
          },
          "limitPerOrder": {
            "description": "Customers are limited to this quantity of this packaged product per order.",
            "type": "integer",
            "format": "int32"
          },
          "servings-per-container": {
            "description": "Servings per container. The rest of the nutrition information is in product.nutrition-facts, but the number of servings per container depends on the packaging size. For composite packaging (e.g. a 12 x 6 x 2 oz case), the value applies to the smallest component with a nutrition label (e.g. the 2 oz items, if they're labeled, or the 6 x 2 oz boxes, if they're labeled and the 2 oz items are not).",
            "type": "string"
          },
          "product": {
            "description": "The product's ID, unless the `inline` query parameter includes `product`, in which case this is a product object (though it doesn't currently return the whole product response).",
            "type": "integer",
            "format": "int64"
          },
          "primary-category": {
            "description": "The id of the primary category for this packaged product.",
            "type": "integer",
            "format": "int64"
          },
          "next-purchase-arrival": {
            "description": "When the next stock of this packaged is expected to arrive at the warehouse. This will only be included if the `inline` query parameter includes `next-purchase-arrival` or `quantity-on-next-purchase`.",
            "type": "string",
            "format": "date-time"
          },
          "quantity-on-next-purchase": {
            "description": "Package quantity arriving on the next-purchase-arrival. This will only be included if the `inline` query parameter includes `next-purchase-arrival` or `quantity-on-next-purchase`.",
            "type": "number",
            "format": "float"
          },
          "images": {
            "description": "Image URLs of for this package.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "vendors": {
            "description": "This will only be included if the `inline` query parameter includes `vendors`.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/vendor"
            }
          }
        },
        "required": [
          "code",
          "product",
          "size",
          "price",
          "tags"
        ]
      },
      "packagedProductImage": {
        "description": "An association between a packaged product and an image.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "packaged-product": {
            "description": "Code for the associated packaged product.",
            "type": "string"
          },
          "image": {
            "description": "File ID for the associated image.",
            "type": "string"
          },
          "order": {
            "description": "Ordering precedence among other entries associated with this packaged product. Defaults to zero.",
            "type": "integer",
            "format": "int32"
          }
        },
        "required": [
          "id",
          "packaged-product",
          "image"
        ]
      },
      "packagedProductTag": {
        "description": "A type of packaged product or other boolean marker.",
        "type": "object",
        "properties": {
          "slug": {
            "description": "Code used as the primary key for tags.",
            "type": "string"
          },
          "name": {
            "description": "Human-readable tag name.",
            "type": "string"
          },
          "category": {
            "description": "Category code describing the type of tag.",
            "type": "string",
            "enum": [
              "status",
              "price-level",
              "characteristic"
            ]
          }
        }
      },
      "packagedProductTagAssociation": {
        "description": "A packaged product tag representing a saved filter for a person.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "person": {
            "type": "integer",
            "format": "int64"
          },
          "tag": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "person",
          "tag"
        ]
      },
      "product": {
        "description": "A product available for sale (independent of packaging).",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "Sentence-length product name.",
            "type": "string"
          },
          "seo-name": {
            "description": "An SEO-optimized name. A lengthened version of the full name that includes additional keywords or rephrasing, suitable for use in a title tag. When this is unset, the name is a reasonable fallback.",
            "type": "string"
          },
          "treatAsActive": {
            "description": "If true, this product will be published to search engines even when it is inactive (out for season, out long term, or discontinued).",
            "type": "boolean"
          },
          "inactiveDescription": {
            "description": "HTML description applicable only when the product is inactive (out for season, out long term, or discontinued). It should contain specific information pertinent to the inactive status of the product (e.g. details about why it is inactive and what similar products are available instead). It should not duplicate information in short-description or description.",
            "type": "string"
          },
          "short-description": {
            "description": "Paragraph-length, stand-alone, plain-text product description.",
            "type": "string"
          },
          "description": {
            "description": "Long-form, HTML product description. When short-description is set, this value is for additional information which did not fit into short-description. Displaying both short-description and description is not redundant. Displaying only description may be confusing when short-description is available.",
            "type": "string"
          },
          "brand": {
            "description": "The brand associated with this product.",
            "type": "integer",
            "format": "int64"
          },
          "directions": {
            "description": "Product use directions (e.g., cooking suggestions).",
            "type": "string"
          },
          "favorites": {
            "description": "Number of people who've marked this product as a favorite.",
            "type": "integer",
            "format": "int32"
          },
          "ingredients": {
            "description": "Ingredients used in this product (e.g., \"dried cranberries (organic cranberries, organic cane sugar, organic sunflower oil)\").",
            "type": "string"
          },
          "nutrition-facts": {
            "$ref": "#/components/schemas/nutritionFacts"
          },
          "packaging": {
            "description": "Packaged versions of this product.",
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          },
          "substitutions": {
            "description": "Suggested in-stock substitutions.",
            "type": "object",
            "properties": {
              "by-category": {
                "description": "Suggested substitute product IDs which belong to related categories.",
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "int64"
                }
              },
              "staff-picks": {
                "description": "Suggested substitute product IDs which were chosen by staff members.",
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "int64"
                }
              }
            }
          },
          "country-of-origin": {
            "description": "Country of origin for this product.",
            "type": "string"
          },
          "storage": {
            "$ref": "#/components/schemas/storage"
          },
          "slug": {
            "description": "A slug generated from the product name.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "nutritionFacts": {
        "description": "Nutrition facts.",
        "type": "object",
        "properties": {
          "headers": {
            "description": "Nutrition-fact headers (e.g. \"Serving Size 1 cake (19g)\" or \"Calories 60\").",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "daily-values": {
            "description": "Nutrition facts daily values.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nutritionFactsDailyValue"
            }
          }
        }
      },
      "nutritionFactsDailyValue": {
        "description": "A nutrition facts daily value.",
        "type": "object",
        "properties": {
          "indent": {
            "description": "If true, this label should be indented (e.g. an indented \"Dietary Fiber\" entry might follow a non-indented \"Total Carbohydrate\" entry).",
            "type": "boolean"
          },
          "label": {
            "description": "Daily value label (e.g. \"Total Carbohydrate 14g\", \"Calcium\").",
            "type": "string"
          },
          "percentage": {
            "description": "Daily value percentage (e.g., \"10\" or \"<1\").",
            "type": "string"
          }
        },
        "required": [
          "indent",
          "label",
          "percentage"
        ]
      },
      "brand": {
        "description": "A brand which may be associated with several products.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "url": {
            "description": "Homepage for the brand.",
            "type": "string",
            "format": "url"
          },
          "slug": {
            "description": "A slug generated from the brand name.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "_price": {
        "description": "A helper object for `price`.",
        "type": "object",
        "properties": {
          "dollars": {
            "description": "Price of the packaging in dollars.",
            "type": "number",
            "format": "float",
            "minimum": 0
          },
          "per-pound": {
            "description": "Whether the `dollars` value is per-pound or per-package.",
            "type": "boolean"
          },
          "discount": {
            "description": "Text for the discount (e.g. \"12%\", or \"$3.50\").",
            "type": "string"
          },
          "dollars-per-unit": {
            "description": "The per-unit price.",
            "type": "number",
            "format": "float",
            "minimum": 0
          },
          "rewards-rate": {
            "description": "Rewards rate (as a percentage) earned for this packaging. This will only be set for packaging with a fixed rewards rate. The rewards earned for this product will be the price (after sales) * min(max(`person.rewards-rate`, `product.rewards-rate`), `product.maxRewardsRate`) / 100, rounded to the nearest cent, rounding half to even.",
            "type": "integer",
            "format": "int32",
            "minimum": 0
          },
          "maxRewardsRate": {
            "description": "The maximum rewards rate that could be earned for this product. A value of 0 means that no rewards will be earned.",
            "type": "integer",
            "format": "int32",
            "minimum": 0
          },
          "unit": {
            "description": "The unit for `dollars-per-unit`.",
            "type": "string"
          }
        },
        "required": [
          "maxRewardsRate",
          "dollars"
        ]
      },
      "priceLevel": {
        "description": "A customer property to pick the right price from 'price'.",
        "type": "string",
        "enum": [
          "retail",
          "wholesale",
          "member"
        ]
      },
      "permission": {
        "description": "An API authorization or authorization category.",
        "type": "string",
        "enum": [
          "staff",
          "superuser"
        ]
      },
      "price": {
        "description": "Product price information.",
        "type": "object",
        "properties": {
          "retail": {
            "$ref": "#/components/schemas/_price"
          },
          "wholesale": {
            "$ref": "#/components/schemas/_price"
          },
          "member": {
            "$ref": "#/components/schemas/_price"
          }
        }
      },
      "category": {
        "description": "A category available for sale.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "A phrase naming the category. This should be understandable (but not necessarily unique) without any further context. It must be unique for categories sharing a given parent.",
            "type": "string"
          },
          "short-name": {
            "description": "A word or two naming the category. A shortened version of the full name that drops any words already contained in the category's ancestors' short names. This will be used in places where the ancestor short names are in close proximity (e.g. URL slugs) to avoid having the same word many times. When this is unset, the name is a reasonable fallback.",
            "type": "string"
          },
          "seo-name": {
            "description": "An SEO-optimized name for the category. A lengthened version of the full name that includes additional keywords or rephrasing, suitable for use in a title tag. When this is unset, the name is a reasonable fallback.",
            "type": "string"
          },
          "description": {
            "description": "A sentence or two with a stand-alone category description. When this is unset, the nearest ancestor description is a reasonable fallback.",
            "type": "string"
          },
          "image": {
            "description": "A picture of this category. When set for a fetched category, the value will be a URL. When set for an uploaded category, file IDs and media URLs can be used interchangeably.",
            "type": "string"
          },
          "parent": {
            "description": "Category ID for the parent category.",
            "type": "integer",
            "format": "int64"
          },
          "ancestors": {
            "description": "Ancestor categories. If set, `ancestors[0]` is the parent category and the final `ancestors` entry is the root category. Include \"ancestors\" in the `inline` query parameter if you need this.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/category"
            }
          },
          "depth": {
            "description": "The number of ancestor categories. Include \"depth\" in the `inline` query parameter if you need this.",
            "type": "integer",
            "format": "int32"
          },
          "primary": {
            "description": "Is this a primary category?.",
            "type": "boolean"
          },
          "active": {
            "description": "Is this category active?.",
            "type": "boolean"
          },
          "keywords": {
            "type": "array",
            "items": {
              "description": "A keyword for this category.",
              "type": "string"
            }
          },
          "featured": {
            "description": "Ordering precedence for likely customer interest. Defaults to zero.",
            "type": "integer",
            "format": "int32"
          },
          "slug": {
            "description": "A slug generated from the category short-name (or name if short-name is not defined).",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "updateCategory": {
        "description": "A category to update.",
        "type": "object",
        "properties": {
          "name": {
            "description": "A phrase naming the category. This should be understandable (but not necessarily unique) without any further context. It must be unique for categories sharing a given parent.",
            "type": "string"
          },
          "short-name": {
            "description": "A word or two naming the category. A shortened version of the full name that drops any words already contained in the category's ancestors' short names. This will be used in places where the ancestor short names are in close proximity (e.g. URL slugs) to avoid having the same word many times. When this is unset, the name is a reasonable fallback.",
            "type": "string"
          },
          "seo-name": {
            "description": "An SEO-optimized name for the category. A lengthened version of the full name that includes additional keywords or rephrasing, suitable for use in a title tag. When this is unset, the name is a reasonable fallback.",
            "type": "string"
          },
          "description": {
            "description": "A sentence or two with a stand-alone category description. When this is unset, the nearest ancestor description is a reasonable fallback.",
            "type": "string"
          },
          "image": {
            "description": "A picture of this category. When set for a fetched category, the value will be a URL. When set for an uploaded category, file IDs and media URLs can be used interchangeably.",
            "type": "string"
          },
          "parent": {
            "description": "Category ID for the parent category.",
            "type": "integer",
            "format": "int64"
          },
          "primary": {
            "description": "Is this a primary category?.",
            "type": "boolean"
          },
          "active": {
            "description": "Is this category active?.",
            "type": "boolean"
          },
          "keywords": {
            "type": "array",
            "items": {
              "description": "A keyword for this category.",
              "type": "string"
            }
          },
          "featured": {
            "description": "Ordering precedence for likely customer interest. Defaults to zero.",
            "type": "integer",
            "format": "int32"
          },
          "slug": {
            "description": "A slug generated from the category short-name (or name if short-name is not defined).",
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "purchase": {
        "description": "A purchase order placed by Azure.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "vendor": {
            "description": "Vendor supplying the order.",
            "type": "integer",
            "format": "int64"
          },
          "status": {
            "description": "Purchase's lifecycle stage.",
            "type": "string",
            "enum": [
              "open",
              "submitted",
              "confirmed",
              "shipped",
              "delivered",
              "labeled",
              "reconciled",
              "paid"
            ]
          },
          "submitted": {
            "description": "When the purchase was submitted.",
            "type": "string",
            "format": "date-time"
          },
          "confirmed": {
            "description": "When the purchase was confirmed.",
            "type": "string",
            "format": "date-time"
          },
          "delivered": {
            "description": "When the purchase was delivered.",
            "type": "string",
            "format": "date-time"
          },
          "reconciled": {
            "description": "When the purchase was reconciled.",
            "type": "string",
            "format": "date-time"
          },
          "pickup": {
            "description": "Drop the purchase is destined for (only set for backhaul purchases).",
            "type": "integer",
            "format": "int64"
          },
          "trip": {
            "description": "Trip delivering the purchase (only set for backhaul purchases).",
            "type": "integer",
            "format": "int64"
          },
          "notes": {
            "description": "Free-form Markdown notes for any purchase information that doesn't fit into an existing field.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "vendor",
          "status"
        ]
      },
      "order": {
        "description": "An order placed by a customer.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "customerId": {
            "description": "ID of the customer making the order.",
            "type": "integer",
            "format": "int64"
          },
          "customer": {
            "description": "The person making the order, if the request includes the inlined value \"customer\". Otherwise, for historical reasons, the customer ID.",
            "allOf": [
              {
                "$ref": "#/components/schemas/person"
              }
            ]
          },
          "dropMembershipId": {
            "description": "The membership ID of the customer making the order. Only included if the request includes the inlined value \"dropMembershipId\".",
            "type": "integer",
            "format": "int64"
          },
          "status": {
            "description": "Order's lifecycle stage.",
            "type": "string",
            "enum": [
              "open",
              "placed",
              "confirmed",
              "shipped",
              "lost"
            ]
          },
          "placed": {
            "description": "When the order was placed.",
            "type": "string",
            "format": "date-time"
          },
          "shipped": {
            "description": "When the order was shipped.",
            "type": "string",
            "format": "date-time"
          },
          "target-delivery": {
            "description": "Planned delivery time (fixed before the trip starts, and unset for parcel-carrier orders).",
            "type": "string",
            "format": "date-time"
          },
          "estimated-delivery": {
            "description": "Estimated delivery time (updated after the trip starts until the order is delivered, and unset for parcel-carrier orders).",
            "type": "string",
            "format": "date-time"
          },
          "delivered": {
            "description": "When the order was delivered.",
            "type": "string",
            "format": "date-time"
          },
          "checkout-payment": {
            "$ref": "#/components/schemas/payment"
          },
          "rewards-allocation": {
            "description": "Rewards allocated for this order. For open orders, this value has no side-effects. For placed orders that are not yet shipped, this value will match the associated pending rewards debit amount. When the order ships, this value does not change, but the associated rewards debit will have its amount reduced if the allocated rewards exceed the dollar balance. If, instead of shipping, the placed order returns to open status, the associated pending rewards debit is deleted, releasing those rewards to be allocated towards other orders.",
            "type": "number",
            "format": "float"
          },
          "drop": {
            "description": "Drop the order is destined for (unset for parcel-carrier orders).",
            "type": "integer",
            "format": "int64"
          },
          "trip": {
            "description": "Trip delivering the order (automatically populated for parcel-carrier orders).",
            "type": "integer",
            "format": "int64"
          },
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "parcel-carrier-services": {
            "$ref": "#/components/schemas/orderParcelCarrierServices"
          },
          "perishable-shipping-warning-accepted": {
            "description": "If true, the customer has accepted the warning regarding shipping perishable product.",
            "type": "boolean"
          },
          "cases-shipped": {
            "description": "Total quantity of shipped boxes and bulk stock.",
            "type": "integer",
            "format": "int64"
          },
          "casesShippedBreakdown": {
            "$ref": "#/components/schemas/orderCaseQuantitiesByTemperature"
          },
          "notes": {
            "description": "Warehouse packing instructions.",
            "type": "string"
          },
          "lastApiUpdate": {
            "description": "A datetime denoting when the order or its order-lines were last updated via the API.",
            "type": "string"
          },
          "holdShipmentUntilStockAvailable": {
            "description": "If true, the customer has requested to hold shipment of the order until all requested stock is available.",
            "type": "boolean"
          },
          "parcelCarrierShipByDate": {
            "description": "For parcel carrier orders, this is the date the order needs to ship by. Since we are using ISO format, the string can either be a date or datetime but it will be stored on the backend as a date.",
            "type": "string",
            "format": "date"
          },
          "computed": {
            "description": "Optional computed properties included via the \"computed\" parameter.",
            "type": "object",
            "properties": {
              "totalPriceOrdered": {
                "description": "Dollar value for the sum of all ordered products (does not include potential fees).",
                "type": "number",
                "format": "float"
              },
              "totalPriceShipped": {
                "description": "Dollar value for the sum of all shipped products (does not include potential fees).",
                "type": "number",
                "format": "float"
              },
              "totalFees": {
                "description": "Dollar value for the sum of all order fees (pre or post shipment, dependent on order status).",
                "type": "number",
                "format": "float"
              },
              "cases": {
                "type": "object",
                "properties": {
                  "frozen": {
                    "description": "Count of cases shipped with frozen products.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "refrigeratedAndRoomTemp": {
                    "description": "Count of cases shipped with refrigerated/room-temperature products.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "greenhouse": {
                    "description": "Count of cases shipped with greenhouse products.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "total": {
                    "description": "Total count of cases shipped.",
                    "type": "integer",
                    "format": "int64"
                  }
                }
              },
              "quantityOrdered": {
                "type": "object",
                "properties": {
                  "frozen": {
                    "description": "Total count of frozen products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "refrigerated": {
                    "description": "Total count of refrigerated products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "roomTemp": {
                    "description": "Total count of room temperature products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "greenhouse": {
                    "description": "Total count of greenhouse products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "total": {
                    "description": "Total count of all products ordered.",
                    "type": "number",
                    "format": "float"
                  }
                }
              },
              "quantityShipped": {
                "type": "object",
                "properties": {
                  "frozen": {
                    "description": "Total count of frozen products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "refrigerated": {
                    "description": "Total count of refrigerated products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "roomTemp": {
                    "description": "Total count of room temperature products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "greenhouse": {
                    "description": "Total count of greenhouse products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "total": {
                    "description": "Total count of all products shipped.",
                    "type": "number",
                    "format": "float"
                  }
                }
              },
              "weightOrdered": {
                "type": "object",
                "properties": {
                  "frozen": {
                    "description": "Total weight (in pounds) of frozen products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "refrigerated": {
                    "description": "Total weight (in pounds) of refrigerated products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "roomTemp": {
                    "description": "Total weight (in pounds) of room temperature products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "greenhouse": {
                    "description": "Total weight (in pounds) of greenhouse products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "total": {
                    "description": "Total weight (in pounds) of all products ordered.",
                    "type": "number",
                    "format": "float"
                  }
                }
              },
              "weightShipped": {
                "type": "object",
                "properties": {
                  "frozen": {
                    "description": "Total weight (in pounds) of frozen products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "refrigerated": {
                    "description": "Total weight (in pounds) of refrigerated products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "roomTemp": {
                    "description": "Total weight (in pounds) of room temperature products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "greenhouse": {
                    "description": "Total weight (in pounds) of greenhouse products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "total": {
                    "description": "Total weight (in pounds) of all products shipped.",
                    "type": "number",
                    "format": "float"
                  }
                }
              },
              "volumeOrdered": {
                "type": "object",
                "properties": {
                  "frozen": {
                    "description": "Total volume (in cubic feet) of frozen products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "refrigerated": {
                    "description": "Total volume (in cubic feet) of refrigerated products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "roomTemp": {
                    "description": "Total volume (in cubic feet) of room temperature products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "greenhouse": {
                    "description": "Total volume (in cubic feet) of greenhouse products ordered.",
                    "type": "number",
                    "format": "float"
                  },
                  "total": {
                    "description": "Total volume (in cubic feet) of all products ordered.",
                    "type": "number",
                    "format": "float"
                  }
                }
              },
              "volumeShipped": {
                "type": "object",
                "properties": {
                  "frozen": {
                    "description": "Total volume (in cubic feet) of frozen products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "refrigerated": {
                    "description": "Total volume (in cubic feet) of refrigerated products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "roomTemp": {
                    "description": "Total volume (in cubic feet) of room temperature products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "greenhouse": {
                    "description": "Total volume (in cubic feet) of greenhouse products shipped.",
                    "type": "number",
                    "format": "float"
                  },
                  "total": {
                    "description": "Total volume (in cubic feet) of all products shipped.",
                    "type": "number",
                    "format": "float"
                  }
                }
              }
            }
          }
        },
        "required": [
          "id",
          "customer",
          "status"
        ]
      },
      "updateOrder": {
        "description": "An order placed by a customer.",
        "type": "object",
        "properties": {
          "customer": {
            "description": "Customer making the order.",
            "type": "integer",
            "format": "int64"
          },
          "status": {
            "description": "Order's lifecycle stage.",
            "type": "string",
            "enum": [
              "open",
              "placed",
              "shipped",
              "lost"
            ]
          },
          "checkout-payment": {
            "$ref": "#/components/schemas/payment"
          },
          "drop": {
            "description": "Drop the order is destined for (unset for parcel-carrier orders).",
            "type": "integer",
            "format": "int64"
          },
          "trip": {
            "description": "Trip delivering the order (automatically populated for parcel-carrier orders).",
            "type": "integer",
            "format": "int64"
          },
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "parcel-carrier-services": {
            "$ref": "#/components/schemas/orderParcelCarrierServices"
          },
          "perishable-shipping-warning-accepted": {
            "description": "If true, the customer has accepted the warning regarding shipping perishable product.",
            "type": "boolean"
          },
          "notes": {
            "description": "Additional information about the order, including special instructions for Azure's pickers.",
            "type": "string"
          },
          "holdShipmentUntilStockAvailable": {
            "description": "If true, the customer has requested to hold shipment of the order until all requested stock is available.",
            "type": "boolean"
          },
          "parcelCarrierShipByDate": {
            "description": "For parcel carrier orders, this is the date the order needs to ship by. Since we are using ISO format, the string can either be a date or datetime but it will be stored on the backend as a date.",
            "type": "string",
            "format": "date"
          }
        },
        "required": [
          "customer",
          "status"
        ]
      },
      "changedOrder": {
        "description": "An updated order and a list of any side-effects from the update.",
        "type": "object",
        "properties": {
          "order": {
            "$ref": "#/components/schemas/order"
          },
          "changes": {
            "description": "An array of side-effects. Will be set if there were side-effects and unset if there were none.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/orderChange"
            }
          }
        },
        "required": [
          "order"
        ]
      },
      "orderChange": {
        "description": "A side-effect from an order update.",
        "type": "object",
        "properties": {
          "type": {
            "description": "A slug identifying the type of change.",
            "type": "string",
            "enum": [
              "remove-order-line"
            ]
          },
          "reason": {
            "description": "A human-readable description of the change.",
            "type": "string"
          },
          "order-line": {
            "$ref": "#/components/schemas/orderLine"
          }
        },
        "required": [
          "change",
          "reason"
        ]
      },
      "orderCaseQuantitiesByTemperature": {
        "description": "Quantity of shipped boxes and bulk stock by temperature type.",
        "type": "object",
        "properties": {
          "frozen": {
            "description": "Quantity of shipped boxes and bulk stock with the frozen climate.",
            "type": "integer",
            "format": "int32"
          },
          "refrigerated": {
            "description": "Quantity of shipped boxes and bulk stock with the refrigerated climate.",
            "type": "integer",
            "format": "int32"
          },
          "roomTemp": {
            "description": "Quantity of shipped boxes and bulk stock with the room temperature climate.",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "orderLine": {
        "description": "A per-product entry in an order.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "order": {
            "description": "Order that the order-line belongs to.",
            "type": "integer",
            "format": "int64"
          },
          "packaged-product": {
            "description": "Packaged product code that is being ordered.",
            "type": "string"
          },
          "product": {
            "description": "Product ID of the packaged product that is being ordered.",
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "Most order lines are for packaged products, but Azure sometimes bills for less concrete items like catalog ads. This field holds a brief description of the line, and should be used for invoices instead of following packaged-product (which may not be set).",
            "type": "string"
          },
          "quantity-ordered": {
            "description": "Number of product instances requested.",
            "type": "integer",
            "format": "int32"
          },
          "quantity-shipped": {
            "description": "Number of product instances delivered.",
            "type": "number",
            "format": "float"
          },
          "weight": {
            "description": "Weight of the shipped products in pounds (estimated until picking time).",
            "type": "number",
            "format": "float"
          },
          "volume": {
            "description": "Volume of the shipped products in cubic feet (estimated until picking time).",
            "type": "number",
            "format": "float"
          },
          "price": {
            "description": "The total price for this line in dollars (estimated until picking time). The per-unit price used to calculate this total is currently locked in when you place the order.",
            "type": "number",
            "format": "float"
          },
          "rewards": {
            "description": "The total rewards earned by this line (estimated until picking time). The per-unit rewards used to calculate this total are currently locked in when you place the order.",
            "type": "number",
            "format": "float"
          },
          "warnings": {
            "description": "An array of warnings about this product.",
            "type": "array",
            "items": {
              "description": "Warnings about products that a customer can associate with this order, but maybe should not (e.g. that is is likely to expire before reaching the customer).",
              "type": "string"
            }
          }
        },
        "required": [
          "id",
          "order",
          "name",
          "quantity-ordered",
          "weight",
          "volume"
        ]
      },
      "updateOrderLine": {
        "description": "A per-product entry in an order.",
        "type": "object",
        "properties": {
          "order": {
            "description": "Order that the order-line belongs to.",
            "type": "integer",
            "format": "int64"
          },
          "packaged-product": {
            "description": "Packaged product code that is being ordered.",
            "type": "string"
          },
          "name": {
            "description": "Most order lines are for packaged products, but Azure sometimes bills for less concrete items like catalog ads. This field holds a brief description of the line, and should be used for invoices instead of following packaged-product (which may not be set).",
            "type": "string"
          },
          "quantity-ordered": {
            "description": "Number of product instances requested.",
            "type": "integer",
            "format": "int32"
          }
        },
        "required": [
          "order",
          "quantity-ordered"
        ]
      },
      "orderFee": {
        "description": "An additional charge associated with an order (estimated until picking time).",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "order": {
            "description": "Order that the fee belongs to.",
            "type": "integer",
            "format": "int64"
          },
          "type": {
            "$ref": "#/components/schemas/orderFeeType"
          },
          "amount": {
            "description": "Dollar value for the fee.",
            "type": "number",
            "format": "float"
          },
          "climate": {
            "$ref": "#/components/schemas/shippingClimate"
          },
          "shipping-service": {
            "$ref": "#/components/schemas/shippingService"
          },
          "notes": {
            "description": "Additional information about the reason or amount for the fee.",
            "type": "string"
          }
        },
        "required": [
          "order",
          "type",
          "amount"
        ]
      },
      "orderFeeType": {
        "description": "A property for an order fee.",
        "type": "string",
        "enum": [
          "shipping",
          "small-order"
        ]
      },
      "dropShippingFee": {
        "description": "Information for calculating shipping costs for orders delivered to a stop.",
        "type": "object",
        "properties": {
          "percent": {
            "description": "The `shipping` order fee is the total order-line price over all lines on the order, multiplied by this percentage, and then rounded to the nearest cent.",
            "type": "number",
            "format": "float"
          }
        }
      },
      "orderParcelCarrierEstimate": {
        "description": "A parcel carrier shipping estimate for a given order or portion of order.",
        "type": "object",
        "properties": {
          "cost": {
            "description": "The cost of the shipping service.",
            "type": "number",
            "format": "float"
          },
          "climate": {
            "$ref": "#/components/schemas/shippingClimate"
          },
          "service": {
            "description": "The parcel carrier service used for this estimate.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/shippingService"
            }
          },
          "expires": {
            "description": "The date-time when this estimate expires. Orders placed for this climate/service after that expiration may have a different fee or delivery estimates.",
            "type": "string",
            "format": "date-time"
          },
          "shipping-date": {
            "description": "The estimated date when the covered order-lines will ship.",
            "type": "string",
            "format": "date"
          },
          "earliest-delivery": {
            "description": "The estimated earliest delivery date (inclusive) for the covered order-lines.",
            "type": "string",
            "format": "date"
          },
          "latest-delivery": {
            "description": "The estimated latest delivery date (inclusive) for the covered order-lines.",
            "type": "string",
            "format": "date"
          },
          "contact-for-quote": {
            "description": "The customer should contact this person or team for a personalized shipping quote for this service.",
            "type": "object",
            "properties": {
              "name": {
                "description": "Name of the person or team.",
                "type": "string"
              },
              "email": {
                "description": "Email for the person or team.",
                "type": "string",
                "format": "email"
              },
              "telephone": {
                "description": "E.123 telephone number for the person or team.",
                "type": "string",
                "format": "telephone"
              }
            }
          }
        },
        "required": [
          "climate",
          "service"
        ]
      },
      "orderParcelCarrierServices": {
        "description": "Parcel carrier services selected for an order.",
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/shippingService"
          },
          "dry": {
            "$ref": "#/components/schemas/shippingService"
          },
          "chilled/frozen": {
            "$ref": "#/components/schemas/shippingService"
          }
        }
      },
      "vendor": {
        "description": "A company that sells products to Azure.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "active": {
            "description": "Whether or not this vendor is actively supplying purchases.",
            "type": "boolean"
          },
          "url": {
            "description": "Homepage for the vendor.",
            "type": "string",
            "format": "url"
          },
          "indie": {
            "description": "Whether or not this vendor is a privately held company.",
            "type": "boolean"
          },
          "account": {
            "description": "Vendor's identifier for Azure.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "active"
        ]
      },
      "accountEntry": {
        "description": "A dollar entry in a person's account.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "person": {
            "description": "Person associated with the account.",
            "type": "integer",
            "format": "int64"
          },
          "amount": {
            "description": "Dollar value for the entry (positive for credits like customer payments, negative for debits like order charges).",
            "type": "number",
            "format": "float"
          },
          "date": {
            "description": "When the entry was added.",
            "type": "string",
            "format": "date"
          },
          "notes": {
            "description": "A line of Markdown identifying the entry (e.g. \"charge for order 123\" or \"payed with card ending in 0123\").",
            "type": "string"
          },
          "balance": {
            "description": "Account balance after this account entry.",
            "type": "number",
            "format": "float"
          }
        },
        "required": [
          "id",
          "person",
          "amount",
          "date"
        ]
      },
      "creditCard": {
        "description": "A credit card (one of our supported payment methods).",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "type": {
            "description": "String identifying this payment method.",
            "type": "string",
            "enum": [
              "credit-card"
            ]
          },
          "active": {
            "description": "Whether or not this payment method is available for further activity.",
            "type": "boolean"
          },
          "person": {
            "description": "Person associated with this payment method.",
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "Billing name (which may differ from the associated person's name).",
            "type": "string"
          },
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "issuer": {
            "description": "Provider network. You can determine this from the leading digits of the card number, but we don't store those digits.",
            "type": "string"
          },
          "last-four": {
            "description": "Last four digits of the card number for identification.",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration date. We only use the month and year; the day will always be '01'.",
            "type": "string",
            "format": "date"
          }
        },
        "required": [
          "id",
          "type",
          "active",
          "person",
          "name",
          "address",
          "last-four",
          "expiration"
        ]
      },
      "newCreditCard": {
        "description": "Azure does not store much credit card information internally (we use an external card processor), but we do need all of the information for the initial upload so we can pass it along to the external processor.",
        "type": "object",
        "properties": {
          "type": {
            "description": "String identifying this payment method.",
            "type": "string",
            "enum": [
              "credit-card"
            ]
          },
          "active": {
            "description": "Whether or not this payment method is available for further activity. Defaults to true.",
            "type": "boolean"
          },
          "person": {
            "description": "Person associated with this payment method.",
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "Billing name (which may differ from the associated person's name).",
            "type": "string"
          },
          "address": {
            "description": "Billing address associated with this credit card.",
            "type": "integer",
            "format": "int64"
          },
          "number": {
            "description": "Card number.",
            "type": "string"
          },
          "security-code": {
            "description": "Security code (also known as the verification value).",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration date. We only use the month and year and ignore the day (which you should set to '01').",
            "type": "string",
            "format": "date"
          }
        },
        "required": [
          "type",
          "person",
          "name",
          "address",
          "number",
          "security-code",
          "expiration"
        ]
      },
      "genericPaymentMethod": {
        "description": "One of our supported payment methods that does not have properties beyond the generic payment-method properties.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "type": {
            "description": "String identifying this payment method. cash-on-delivery means customers must pay for their order in cash to pick up the order. hold-for-payment means customers must pay for the order before Azure will ship it. net-N means the order must be paid for within N days. payroll-deduction means the invoiced price will be deducted from the customer's (an Azure employee) next paycheck.",
            "type": "string",
            "enum": [
              "cash-on-delivery",
              "hold-for-payment",
              "net-10-days",
              "net-30-days",
              "payroll-deduction"
            ]
          },
          "active": {
            "description": "Whether or not this payment method is available for further activity.",
            "type": "boolean"
          },
          "person": {
            "description": "Person associated with this payment method.",
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "id",
          "type",
          "active",
          "person"
        ]
      },
      "paymentMethod": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/creditCard"
          },
          {
            "$ref": "#/components/schemas/genericPaymentMethod"
          }
        ]
      },
      "newPaymentMethod": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/newCreditCard"
          }
        ]
      },
      "payment": {
        "description": "A payment instance where an amount will be (or has been) charged via a payment-method.",
        "type": "object",
        "properties": {
          "payment-method": {
            "description": "Payment-method ID to use (or which was used).",
            "type": "integer",
            "format": "int64"
          },
          "type": {
            "description": "The type of payment used.",
            "type": "string"
          },
          "last-four": {
            "description": "The last four digits of the credit card used. Only included if the payment type is Credit Card.",
            "type": "string"
          },
          "amount": {
            "description": "Amount to charge (or which was charged) in dollars.",
            "type": "number",
            "format": "float"
          },
          "paid": {
            "description": "Has the payment been charged?.",
            "type": "boolean"
          }
        },
        "required": [
          "payment-method"
        ]
      },
      "registrationRequest": {
        "description": "A request for registering a new person.",
        "type": "object",
        "properties": {
          "person": {
            "$ref": "#/components/schemas/updatePerson"
          },
          "catalog": {
            "description": "Set to true to receive the catalog after registration.",
            "type": "boolean"
          },
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "email": {
            "description": "The registrant's primary email address. Will have a preference level of 100.",
            "type": "string",
            "format": "email"
          },
          "telephone": {
            "description": "The registrant's telephone numbers (currently only supports 'voice' and 'text' types).",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/telephone"
            }
          },
          "drop": {
            "description": "The registrant's chosen drop.",
            "type": "integer",
            "format": "int64"
          },
          "context": {
            "$ref": "#/components/schemas/registrationContext"
          },
          "authentication-base-url": {
            "description": "Redirect URL for the authentication UI. The authentication notification points customers at {authentication-base-url}{authentication-token} to authenticate a new session.",
            "type": "string",
            "format": "url"
          },
          "post-affiliate-pro": {
            "$ref": "#/components/schemas/postAffiliatePro"
          }
        },
        "required": [
          "person",
          "email",
          "authentication-base-url"
        ]
      },
      "registrationContext": {
        "description": "The context in which the registration request is being made (to select between available notification templates). Defaults to \"registration\".",
        "type": "string",
        "enum": [
          "registration",
          "checkout",
          "catalog-request"
        ]
      },
      "reward": {
        "description": "A reward entry.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "person": {
            "description": "Person associated with the reward.",
            "type": "integer",
            "format": "int64"
          },
          "amount": {
            "description": "Reward value for the entry (positive for credits, negative for debits).",
            "type": "number",
            "format": "float"
          },
          "type": {
            "description": "This entry's reward type.",
            "type": "string",
            "enum": [
              "earned",
              "used",
              "expired",
              "promotion"
            ]
          },
          "settled": {
            "description": "When the entry was settled. This will be unset for pending debits, and will be set for all settled debits.",
            "type": "string",
            "format": "date-time"
          },
          "order": {
            "description": "The order which produced (for credits) or consumed (for debits) this entry.",
            "type": "integer",
            "format": "int64"
          },
          "account-entry": {
            "description": "The account-entry credit created by this entry. This will be set for rewards debits where the referenced account-entry credit shows the dollar increase associated with this rewards decrease.",
            "type": "integer",
            "format": "int64"
          },
          "total-credit": {
            "description": "Settled credit total through this reward entry.",
            "type": "number",
            "format": "float",
            "minimum": 0
          },
          "total-debit": {
            "description": "Settled debit total through this reward entry.",
            "type": "number",
            "format": "float",
            "minimum": 0
          },
          "total-pending": {
            "description": "Pending debit total through this reward entry.",
            "type": "number",
            "format": "float",
            "minimum": 0
          }
        },
        "required": [
          "id",
          "person",
          "amount",
          "order"
        ]
      },
      "postAffiliatePro": {
        "description": "Business logic around the affiliate program is handled by Beehive. If Beehive determines the referrer is due credit then this information is passed on to Post Affiliate Pro as a sale.",
        "type": "object",
        "properties": {
          "referrer": {
            "description": "Post Affiliate Pro referring affiliate code.",
            "type": "string"
          },
          "visitor": {
            "description": "Post Affiliate Pro visitor id. This information is opaque to Azure.",
            "type": "string"
          },
          "banner": {
            "description": "Post Affiliate Pro banner ad id. This information is opaque to Azure.",
            "type": "string"
          }
        },
        "required": [
          "referrer",
          "visitor"
        ]
      },
      "registrationResponse": {
        "description": "The registration response.",
        "type": "object",
        "properties": {
          "session": {
            "$ref": "#/components/schemas/session"
          },
          "auth-token": {
            "description": "Auth token. Can be sent to login to authenticate a new session.",
            "type": "string"
          },
          "resend-token": {
            "description": "Resend token. Can be sent to resendRegistrationNotification to trigger a new registration notification.",
            "type": "string"
          }
        },
        "required": [
          "session",
          "resend-token"
        ]
      },
      "resendRegistrationNotification": {
        "description": "A request for another registration notification.",
        "type": "object",
        "properties": {
          "context": {
            "$ref": "#/components/schemas/registrationContext"
          },
          "authentication-base-url": {
            "description": "Redirect URL for the authentication UI. The authentication notification points customers at {authentication-base-url}{authentication-token} to authenticate a new session.",
            "type": "string",
            "format": "url"
          },
          "token": {
            "description": "The registrant's resend token.",
            "type": "string"
          }
        },
        "required": [
          "authentication-base-url",
          "token"
        ]
      },
      "token": {
        "description": "Authentication credentials.",
        "type": "object",
        "properties": {
          "token": {
            "description": "Token for authentication.",
            "type": "string"
          }
        },
        "required": [
          "token"
        ]
      },
      "usernamePassword": {
        "description": "Authentication credentials.",
        "type": "object",
        "properties": {
          "username": {
            "description": "Username for authentication. Instead of your username, you could also use your primary email address or your person ID here.",
            "type": "string"
          },
          "password": {
            "description": "Password for authentication.",
            "type": "string"
          }
        },
        "required": [
          "username",
          "password"
        ]
      },
      "passwordResetRequest": {
        "description": "A request for a password-reset token.",
        "type": "object",
        "properties": {
          "base-url": {
            "description": "Redirect URL for the password reset UI. The password reset email points customers at {base-url}{confirmation-token} to confirm their password reset.",
            "type": "string",
            "format": "url"
          },
          "email": {
            "description": "The email address for the person whose password will be reset. Instead of the email address, you may also use your username or person ID here.",
            "type": "string"
          }
        },
        "required": [
          "base-url",
          "email"
        ]
      },
      "passwordResetConfirmation": {
        "description": "A request to reset a password using a password-reset token.",
        "type": "object",
        "properties": {
          "token": {
            "description": "The password-reset confirmation token.",
            "type": "string"
          },
          "password": {
            "description": "The new password.",
            "type": "string"
          }
        },
        "required": [
          "token",
          "password"
        ]
      },
      "notificationChannel": {
        "description": "Channel technology for pushing user notifications.",
        "type": "string",
        "enum": [
          "email",
          "text"
        ]
      },
      "telephone": {
        "description": "A telephone number.",
        "type": "object",
        "properties": {
          "pref": {
            "description": "Mark a preferred-use telephone number (assumed false).",
            "type": "boolean"
          },
          "type": {
            "description": "An array of properties for this number.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/telephoneType"
            }
          },
          "number": {
            "description": "E.123 telephone number.",
            "type": "string",
            "format": "telephone"
          }
        },
        "required": [
          "type",
          "number"
        ]
      },
      "telephoneType": {
        "description": "A property of a telephone number.",
        "type": "string",
        "enum": [
          "text",
          "voice"
        ]
      },
      "person": {
        "description": "A person (customer, vendor, employee, ..).",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "active": {
            "description": "Whether or not this account is active. Inactive users cannot log in.",
            "type": "boolean"
          },
          "password-usable": {
            "description": "Whether or not this account has a usable password.",
            "type": "boolean"
          },
          "email": {
            "description": "The person's preferred, error-less email address (set if the \"inline\" query parameter contains \"email\").",
            "type": "string",
            "format": "email"
          },
          "can-email": {
            "description": "Can Azure contact this person for reasons other than registration.",
            "type": "boolean"
          },
          "sale-magazine": {
            "description": "Set to true to receive the sale magazine.",
            "type": "boolean"
          },
          "company": {
            "description": "Employer name.",
            "type": "string"
          },
          "allow-social-media": {
            "description": "Does this person want social media links to display.",
            "type": "boolean"
          },
          "price-level": {
            "$ref": "#/components/schemas/priceLevel"
          },
          "rewards-rate": {
            "description": "Rewards rate (as a percentage) for this customer. The rewards earned for a product will be the price (after sales) * min(max(`person.rewards-rate`, `product.rewards-rate`), `product.maxRewardsRate`) / 100, rounded to the nearest cent, rounding half to even.",
            "type": "integer",
            "format": "int32",
            "minimum": 0
          },
          "notifications": {
            "$ref": "#/components/schemas/personNotifications"
          },
          "permissions": {
            "description": "API permissions for this person.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/permission"
            }
          },
          "order-place-issue": {
            "description": "If the person should be warned or blocked from placing orders, this property will be set with a slugged reason and recommended action. Only set if the \"inline\" query parameter contains \"order-place-issue\".",
            "type": "string",
            "enum": [
              "outstanding-balance-contact",
              "outstanding-balance-pay",
              "outstanding-balance-warn"
            ]
          },
          "internal-notes": {
            "description": "Free-form Markdown notes for any internal information that doesn't fit into an existing field. Only Azure employees can view or edit this information, although it may be passed into the registerPerson endpoint when registering new people.",
            "type": "string"
          },
          "affiliate-code": {
            "description": "Affiliate code to be used with URL shares.",
            "type": "string"
          },
          "affiliate-username": {
            "description": "Affiliate username (email).",
            "type": "string",
            "format": "email"
          },
          "is-allowed-to-be-affiliate": {
            "description": "Is allowed to be an affiliate.",
            "type": "boolean"
          },
          "affiliate-campaign": {
            "description": "The affiliate campaign the person is a participant of.",
            "type": "string",
            "enum": [
              "lead",
              "community"
            ]
          },
          "marketing-slug": {
            "description": "A person's unique, primary marketing slug used, e.g., for the Azure Share program.",
            "type": "string"
          },
          "recency": {
            "description": "Order recency ranking. Higher rankings for customers with more recent orders.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 5
          },
          "frequency": {
            "description": "Order frequency ranking. Higher rankings for customers with more frequent orders.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 5
          },
          "monetary": {
            "description": "Order value ranking. Higher rankings for customers with larger orders.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 5
          },
          "first-order-placed": {
            "description": "When this customer's first order was placed. This timestamp does not change once set, even if the initial order is subsequently deleted.",
            "type": "string",
            "format": "date-time"
          },
          "last-order-placed": {
            "description": "When this customer's most recent order was placed. This timestamp includes all open-to-placed transitions, regardless of whether the related order is subsequently deleted.",
            "type": "string",
            "format": "date-time"
          },
          "is-drop-coordinator": {
            "description": "Is a drop coordinator (inclusive of both primary contact and managers). Only set if the \"inline\" query parameter contains \"is-drop-coordinator\".",
            "type": "boolean"
          }
        },
        "required": [
          "id",
          "name",
          "notifications"
        ]
      },
      "updatePerson": {
        "description": "A person (customer, vendor, employee, ..).",
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "password": {
            "description": "Password for authentication.",
            "type": "string"
          },
          "can-email": {
            "description": "Can Azure contact this person for reasons other than registration? Defaults to true when creating a person.",
            "type": "boolean"
          },
          "sale-magazine": {
            "description": "Subscribed to receive the sale magazine?  Defaults to false when creating a person.",
            "type": "boolean"
          },
          "company": {
            "description": "Employer name.",
            "type": "string"
          },
          "allow-social-media": {
            "description": "Does this person want social media links to display?  Defaults to true when creating a person.",
            "type": "boolean"
          },
          "notifications": {
            "$ref": "#/components/schemas/personNotifications"
          },
          "affiliate-code": {
            "description": "Affiliate code to be used with URL shares. Only users with the update-person permission can edit this information.",
            "type": "string"
          },
          "is-allowed-to-be-affiliate": {
            "description": "Is allowed to be an affiliate. Only users with the update-person permission can edit this information.",
            "type": "boolean"
          }
        }
      },
      "updatePersonUserPassword": {
        "description": "A person (customer, vendor, employee, ..) with the logged in user's password.",
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "password": {
            "description": "Password for authentication.",
            "type": "string"
          },
          "can-email": {
            "description": "Can Azure contact this person for reasons other than registration.",
            "type": "boolean"
          },
          "sale-magazine": {
            "description": "Subscribed to receive the sale magazine.",
            "type": "boolean"
          },
          "company": {
            "description": "Employer name.",
            "type": "string"
          },
          "allow-social-media": {
            "description": "Does this person want social media links to display.",
            "type": "boolean"
          },
          "user-password": {
            "description": "The authenticated person's password. Required when changing password for users with a usable password.",
            "type": "string"
          },
          "notifications": {
            "$ref": "#/components/schemas/personNotifications"
          }
        }
      },
      "personNotifications": {
        "description": "Configure if and how a user receives per-user notifications.",
        "type": "object",
        "properties": {
          "abandonedCart": {
            "description": "Sent when an unplaced order is left in a cart.",
            "format": "array",
            "items": {
              "$ref": "#/components/schemas/notificationChannel"
            }
          },
          "checkout": {
            "description": "Sent after checking out orders.",
            "format": "array",
            "items": {
              "$ref": "#/components/schemas/notificationChannel"
            }
          },
          "delivery": {
            "description": "Sent after order delivery, and after updates to delivery estimates.",
            "format": "array",
            "items": {
              "$ref": "#/components/schemas/notificationChannel"
            }
          },
          "payment": {
            "description": "Sent after Azure processes a payment.",
            "format": "array",
            "items": {
              "$ref": "#/components/schemas/notificationChannel"
            }
          },
          "invoice": {
            "description": "Sent when new invoices are generated.",
            "format": "array",
            "items": {
              "type": "string",
              "enum": [
                "paper",
                "email"
              ]
            }
          }
        }
      },
      "address": {
        "description": "An address following the convention of http://microformats.org/wiki/h-adr and https://tools.ietf.org/html/rfc6350#section-6.3.1, with an additional `name` property.",
        "type": "object",
        "properties": {
          "name": {
            "description": "Contact name for this address (e.g. \"Mr. John Q. Public, Esq.\").",
            "type": "string"
          },
          "post-office-box": {
            "type": "string"
          },
          "extended-address": {
            "type": "string"
          },
          "street-address": {
            "type": "string"
          },
          "locality": {
            "type": "string"
          },
          "region": {
            "description": "Required for the United States and Canada, optional for other countries.",
            "type": "string"
          },
          "postal-code": {
            "type": "string"
          },
          "country": {
            "description": "ISO 3166-1 alpha-3 code for the country. On push, you can set the alpha-2 code or case-insensitive name instead, or you can use an inline country object.",
            "type": "string"
          },
          "preference": {
            "description": "Ordering precedence for the findAddresses. Defaults to zero.",
            "type": "integer",
            "format": "int32"
          }
        },
        "required": [
          "locality",
          "country"
        ]
      },
      "country": {
        "description": "A country.",
        "type": "object",
        "properties": {
          "name": {
            "description": "Country name.",
            "type": "string"
          },
          "iso": {
            "description": "The country's ISO 3166-1 alpha-2 code.",
            "type": "string"
          },
          "iso3": {
            "description": "The country's ISO 3166-1 alpha-3 code.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "iso",
          "iso3"
        ]
      },
      "region": {
        "description": "A country region (US state or Canadian province).",
        "type": "object",
        "properties": {
          "name": {
            "description": "Region name.",
            "type": "string"
          },
          "abbreviation": {
            "type": "string"
          },
          "country-iso3": {
            "type": "string"
          }
        }
      },
      "location": {
        "description": "A named geographic coordinate with an enumerated label.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "geo": {
            "$ref": "#/components/schemas/geo"
          },
          "label": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "geo"
        ]
      },
      "geo": {
        "description": "A geographical coordinate.",
        "type": "object",
        "properties": {
          "latitude": {
            "type": "number",
            "format": "float"
          },
          "longitude": {
            "type": "number",
            "format": "float"
          }
        },
        "required": [
          "latitude",
          "longitude"
        ]
      },
      "email": {
        "description": "An email address.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "address": {
            "type": "string",
            "format": "email"
          },
          "person": {
            "description": "Person associated with this email.",
            "type": "integer",
            "format": "int64"
          },
          "error": {
            "description": "Reason for not using this address (e.g. \"email bounced on 2016-08-15\").",
            "type": "string"
          },
          "preference": {
            "description": "Ordering precedence for the findEmails.",
            "type": "integer",
            "format": "int32"
          }
        },
        "required": [
          "id",
          "address",
          "person"
        ]
      },
      "updateEmailUserPassword": {
        "description": "A request for adding or updating an email address with the logged in user's password.",
        "type": "object",
        "properties": {
          "email": {
            "$ref": "#/components/schemas/email"
          },
          "user-password": {
            "description": "The authenticated person's password. Required for users with a usable password.",
            "type": "string"
          }
        },
        "required": [
          "email"
        ]
      },
      "favorite": {
        "description": "A customer favorite.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "quantity": {
            "type": "integer",
            "format": "int64"
          },
          "packaged-product": {
            "type": "string"
          },
          "product": {
            "type": "integer",
            "format": "int64"
          },
          "customer": {
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "id",
          "quantity",
          "packaged-product",
          "customer"
        ]
      },
      "updateFavorite": {
        "description": "A customer favorite.",
        "type": "object",
        "properties": {
          "quantity": {
            "type": "integer",
            "format": "int64"
          },
          "packaged-product": {
            "type": "string"
          },
          "customer": {
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "quantity",
          "packaged-product",
          "customer"
        ]
      },
      "session": {
        "description": "Session cookie information.",
        "type": "object",
        "properties": {
          "person": {
            "description": "Person ID for the session owner (unset for anonymous sessions).",
            "type": "integer",
            "format": "int64"
          },
          "expires": {
            "description": "Current expiration date-time for this session (http://tools.ietf.org/html/rfc6265#section-5.3, covering both Max-Age and Expires representations, unset if the session expires at browser-close).",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "notification": {
        "description": "A notification to display on the website.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "message": {
            "type": "string"
          },
          "active": {
            "type": "boolean"
          },
          "dismissed": {
            "type": "boolean",
            "description": "If annotate-person is specified in the request, this field will note if the notification has been dismissed."
          }
        },
        "required": [
          "id",
          "message"
        ]
      },
      "notificationDismissal": {
        "description": "A dismissal used to hide a read notification.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "notification": {
            "type": "integer",
            "format": "int64"
          },
          "person": {
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "notification",
          "person"
        ]
      },
      "productAudit": {
        "description": "An audited or auditable product and its packaging.",
        "type": "object",
        "properties": {
          "id": {
            "description": "The product ID (not unique to the audit process).",
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "description": "Sentence-length product name. Copied from `#definitions/product` for easier UI development.",
            "type": "string"
          },
          "packaging": {
            "description": "All related audited and/or non-audited packaged versions of this product.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/packagedProductAudit"
            }
          }
        },
        "required": [
          "id",
          "name",
          "packaging"
        ]
      },
      "packagedProductAudit": {
        "description": "An audited or auditable packaged-product.",
        "type": "object",
        "properties": {
          "id": {
            "description": "The packaged-product id (not unique to the audit process).",
            "type": "string"
          },
          "size": {
            "description": "The old size of the product (e.g. \"12 oz.\" or \"6x12 oz.\").",
            "type": "string"
          },
          "packs": {
            "description": "The new dimensions of package sizes (e.g. \"4\", \"4x32.5\", or \"2x4x32.5\").",
            "type": "string"
          },
          "unit": {
            "description": "The new unit of measurement. You can use any string, but the backend will only be able to make automatic comparisons if you use SI prefixes (e.g. \"mm\" for millimeters) and stick to the following base units: pound, ounce, gram, gallon, liter, quart, pint, cup, fluid ounce, yard, and count",
            "type": "string"
          },
          "audited": {
            "description": "A datetime denoting if and when the packaged-product was last audited.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "size",
          "packs",
          "unit",
          "audited"
        ]
      },
      "updatePackagedProductAudit": {
        "description": "An update to an audited packaged-product.",
        "type": "object",
        "properties": {
          "packs": {
            "description": "The new dimensions of package sizes (e.g. \"4\", \"4x32.5\", or \"2x4x32.5\").",
            "type": "string"
          },
          "unit": {
            "description": "The new unit of measurement. Ideally one of \"\", or \"\", but you can use another unit if none of those fit.",
            "type": "string"
          },
          "size": {
            "description": "Override the auto-generated size (based on packs and unit) with a custom name. This can be useful for adding packaging information (e.g. \"32 floz glass\" to distinguish glass from plastic vinegar bottles).",
            "type": "string"
          },
          "clear-audited": {
            "description": "If true, clear the audited date-time for this packaged-product. If false (the default), set the audited date-time to the current time.",
            "type": "boolean"
          }
        },
        "required": [
          "packs",
          "unit"
        ]
      },
      "printer": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          },
          "delivery": {
            "$ref": "#/components/schemas/printerDeliveryType"
          },
          "format": {
            "$ref": "#/components/schemas/printerFormatType"
          },
          "warehouse": {
            "description": "The warehouse's code.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name",
          "delivery",
          "format",
          "warehouse"
        ]
      },
      "printerDeliveryType": {
        "description": "A property for printer delivery method.",
        "type": "string",
        "enum": [
          "http",
          "cups",
          "bartender"
        ]
      },
      "printerFormatType": {
        "description": "A property for printer format method.",
        "type": "string",
        "enum": [
          "pdf",
          "epl2",
          "bartender"
        ]
      },
      "warehouse": {
        "description": "A physical warehouse or facility.",
        "type": "object",
        "properties": {
          "code": {
            "description": "Slug for stable reference (e.g. \"moro\").",
            "type": "string"
          },
          "name": {
            "description": "Human readable name (e.g. \"Moro\").",
            "type": "string"
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "ip2location": {
        "description": "Location information for an ip address.",
        "type": "object",
        "properties": {
          "address": {
            "$ref": "#/components/schemas/address"
          },
          "geo": {
            "$ref": "#/components/schemas/geo"
          }
        },
        "required": [
          "address",
          "geo"
        ]
      },
      "weight": {
        "description": "Packaged product weight information.",
        "properties": {
          "average": {
            "description": "An estimate of the average weight of the packaged product in pounds.",
            "type": "number",
            "format": "float"
          },
          "minimum": {
            "description": "Minimum weight of the packaged product in pounds.",
            "type": "number",
            "format": "float"
          },
          "maximum": {
            "description": "Maximum weight of the packaged product in pounds.",
            "type": "number",
            "format": "float"
          }
        },
        "required": [
          "average"
        ]
      },
      "error": {
        "required": [
          "code",
          "message"
        ],
        "properties": {
          "code": {
            "description": "HTTP error code (https://tools.ietf.org/html/rfc7231#section-6).",
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "description": "A sentence or two describing the error.",
            "type": "string"
          }
        }
      },
      "truckload": {
        "title": "truckload",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "ID of the truckload (pickset)."
          },
          "truckNumber": {
            "type": "integer",
            "description": "Number of the truck on the trip. This is not necessarily sequential."
          },
          "truckDriverId": {
            "type": "integer",
            "description": "ID of the truck driver on the trip."
          }
        },
        "required": [
          "id",
          "truckNumber"
        ]
      },
      "orderedPackagedProduct": {
        "description": "Aggregated information about packaged products ordered by a customer within the last two years.",
        "type": "object",
        "properties": {
          "code": {
            "description": "The packaged product code that was ordered.",
            "type": "string"
          },
          "productId": {
            "description": "The product ID of the packaged product that was ordered.",
            "type": "integer",
            "format": "int64"
          },
          "orderCount": {
            "description": "The number of this customer's unique shipped orders that this packaged product was ordered on (invoiced within the last two years).",
            "type": "integer",
            "format": "int64"
          },
          "lastOrderInvoiceDate": {
            "description": "The invoice date of the most recent order containing the packaged product.",
            "type": "string",
            "format": "date"
          },
          "lastOrderId": {
            "description": "The ID of the most recent order containing the packaged product.",
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "code",
          "productId",
          "orderCount",
          "lastOrderInvoiceDate",
          "lastOrderId"
        ]
      }
    }
  }
}